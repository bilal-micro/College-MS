<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Spreads.Core</name>
    </assembly>
    <members>
        <member name="F:Spreads.Algorithms.Hash.Blake2b.DefaultDigestLength">
            <summary>The default hash digest length in bytes.  For BLAKE2b, this value is 64.</summary>
        </member>
        <member name="M:Spreads.Algorithms.Hash.Blake2b.ComputeAndWriteHash(System.ReadOnlySpan{System.Byte},Spreads.Buffers.DirectBuffer,System.Span{System.Byte})">
            <summary>Perform an all-at-once BLAKE2b hash computation and write the hash digest to <paramref name="output" />.</summary>
            <remarks>If you have all the input available at once, this is the most efficient way to calculate the hash.</remarks>
            <param name="key">0 to 64 bytes of input for initializing a keyed hash.</param>
            <param name="input">The message bytes to hash.</param>
            <param name="output">Destination buffer into which the hash digest is written.  The buffer must have a capacity of at least <see cref="F:Spreads.Algorithms.Hash.Blake2b.DefaultDigestLength"/>(64) /> bytes.</param>
        </member>
        <member name="M:Spreads.Algorithms.Hash.Blake2b.ComputeAndWriteHash(System.Int32,System.ReadOnlySpan{System.Byte},Spreads.Buffers.DirectBuffer,System.Span{System.Byte})">
            <summary>Perform an all-at-once BLAKE2b hash computation and write the hash digest to <paramref name="output" />.</summary>
            <remarks>If you have all the input available at once, this is the most efficient way to calculate the hash.</remarks>
            <param name="digestLength">The hash digest length in bytes.  Valid values are 1 to 64.</param>
            <param name="key">0 to 64 bytes of input for initializing a keyed hash.</param>
            <param name="input">The message bytes to hash.</param>
            <param name="output">Destination buffer into which the hash digest is written.  The buffer must have a capacity of at least <paramref name="digestLength" /> bytes.</param>
        </member>
        <member name="M:Spreads.Algorithms.Hash.Blake2b.CreateIncrementalHasher(System.Int32,System.ReadOnlySpan{System.Byte})">
            <summary>Create and initialize an incremental BLAKE2b hash computation.</summary>
            <remarks>If you will receive the input in segments rather than all at once, this is the most efficient way to calculate the hash.</remarks>
            <param name="digestLength">The hash digest length in bytes.  Valid values are 1 to 64.</param>
            <param name="key">0 to 64 bytes of input for initializing a keyed hash.</param>
            <returns>An <see cref="T:Spreads.Algorithms.Hash.BLAKE2b.Blake2bContext" /> for updating and finalizing the hash.</returns>
        </member>
        <member name="T:Spreads.Algorithms.Optimization.EvalParametersResult`1">
            <summary>
            Result of evaluating a target function with given parameters.
            </summary>
        </member>
        <member name="M:Spreads.Algorithms.Optimization.GridOptimizer`1.FoldGrid``1(``0,Spreads.Algorithms.Optimization.EvalFolderFunc{`0,``0},Spreads.Algorithms.Optimization.Parameters)">
            <summary>
            Iterate over grid, evaluate target function and fold its results.
            </summary>
        </member>
        <member name="M:Spreads.Algorithms.Optimization.GridOptimizer.Maximize(Spreads.Algorithms.Optimization.Parameters,System.Func{Spreads.Algorithms.Optimization.Parameters,System.Threading.Tasks.ValueTask{System.Double}},System.Boolean)">
            <summary>
            Find parameters that maximize the target function over the parameter grid.
            </summary>
        </member>
        <member name="M:Spreads.Algorithms.Optimization.GridOptimizer.MaximizeWithBigStep(Spreads.Algorithms.Optimization.Parameters,System.Func{Spreads.Algorithms.Optimization.Parameters,System.Threading.Tasks.ValueTask{System.Double}},System.Boolean)">
            <summary>
            Find parameters that maximize the target function over the parameter grid, first searching with big steps.
            </summary>
        </member>
        <member name="M:Spreads.Algorithms.Optimization.Parameter.GetRegion(System.Int32,System.Int32)">
            <summary>
            Epsilon number of step around the position
            </summary>
            <param name="position"></param>
            <param name="epsilon"></param>
            <returns></returns>
        </member>
        <member name="T:Spreads.Algorithms.VectorMath">
            <summary>
            Hardware-accelerated simple math operations.
            </summary>
            <remarks>
            WARNING: Methods in this static class do not perform bound checks and are intended to be used
            as building blocks in other parts that calculate bounds correctly and
            do performs required checks on external input.
            </remarks>
        </member>
        <member name="T:Spreads.Algorithms.VectorSearch">
            <summary>
            Algorithms to find values in contiguous data (memory region or a data structure with an indexer), e.g. <see cref="T:Spreads.Native.Vec`1"/>.
            WARNING: Methods in this static class do not perform bound checks and are intended to be used
            as building blocks in other parts that calculate bounds correctly and
            do performs required checks on external input.
            </summary>
        </member>
        <member name="M:Spreads.Algorithms.VectorSearch.BinarySearch``1(``0@,System.Int32,``0,Spreads.KeyComparer{``0})">
            <summary>
            Performs standard binary search and returns index of the value or its negative binary complement.
            </summary>
        </member>
        <member name="M:Spreads.Algorithms.VectorSearch.BinarySearch``2(``1@,System.Int32,System.Int32,``0,Spreads.KeyComparer{``0})">
            <summary>
            Performs standard binary search and returns index of the value from the beginning of <paramref name="vec"/> (not from <paramref name="start"/>) or its negative binary complement.
            </summary>
        </member>
        <member name="M:Spreads.Algorithms.VectorSearch.SearchToLookup(System.Int32,System.Int32,Spreads.Lookup,System.Int32)">
            <summary>
            Converts a result of a sorted search to result of directional search with direction of <see cref="T:Spreads.Lookup"/>.
            </summary>
        </member>
        <member name="M:Spreads.Algorithms.VectorSearch.BinaryLookup``1(``0@,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            Find value using binary search according to the lookup direction.
            </summary>
        </member>
        <member name="M:Spreads.Algorithms.VectorSearch.BinaryLookup``2(``1@,System.Int32,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            Find value using binary search according to the lookup direction.
            </summary>
        </member>
        <member name="M:Spreads.Algorithms.VectorSearch.InterpolationSearch(System.Int64@,System.Int32,System.Int64)">
            <summary>
            Exponential
            </summary>
        </member>
        <member name="M:Spreads.Algorithms.VectorSearch.InterpolationSearch``1(``0@,System.Int32,System.Int32,System.Int64)">
            <summary>
            Returns index from the beginning of the vector (not from the <paramref name="start"/> parameter).
            </summary>
            <param name="vec"></param>
            <param name="start">Start of the search range.</param>
            <param name="length">Length of the search range.</param>
            <param name="value">Value to search.</param>
        </member>
        <member name="M:Spreads.Algorithms.VectorSearch.InterpolationSearch``1(``0@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns index from the beginning of the vector (not from the <paramref name="start"/> parameter).
            </summary>
            <param name="vec"></param>
            <param name="start">Start of the search range.</param>
            <param name="length">Length of the search range.</param>
            <param name="value">Value to search.</param>
        </member>
        <member name="M:Spreads.Algorithms.VectorSearch.InterpolationSearchGeneric``2(``1@,System.Int32,System.Int32,``0,Spreads.KeyComparer{``0})">
            <summary>
            Returns index from the beginning of the vector (not from the <paramref name="start"/> parameter).
            </summary>
            <param name="vec"></param>
            <param name="start">Start of the search range.</param>
            <param name="length">Length of the search range.</param>
            <param name="value">Value to search.</param>
            <param name="comparer"></param>
        </member>
        <member name="M:Spreads.Algorithms.VectorSearch.InterpolationLookup``1(``0@,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            Find value using binary search according to the lookup direction.
            </summary>
        </member>
        <member name="M:Spreads.Algorithms.VectorSearch.InterpolationLookup``2(``1@,System.Int32,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            Returns index from the beginning of the vector (not from the <paramref name="start"/> parameter).
            </summary>
            <param name="vec"></param>
            <param name="start">Start of the search range.</param>
            <param name="length">Length of the search range.</param>
            <param name="value">Value to search.</param>
            <param name="lookup"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Spreads.Algorithms.VectorSearch.SortedSearch``1(``0@,System.Int32,``0,Spreads.KeyComparer{``0})">
            <summary>
            Performs interpolation search for well-known types and binary search for other types.
            </summary>
        </member>
        <member name="M:Spreads.Algorithms.VectorSearch.SortedSearch``2(``1@,System.Int32,System.Int32,``0,Spreads.KeyComparer{``0})">
            <summary>
            Performs interpolation search for well-known types and binary search for other types.
            </summary>
        </member>
        <member name="M:Spreads.Algorithms.VectorSearch.SortedLookup``1(``0@,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            Performs interpolation lookup for well-known types and binary lookup for other types.
            </summary>
        </member>
        <member name="M:Spreads.Algorithms.VectorSearch.SortedLookup``2(``1@,System.Int32,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            Performs interpolation lookup for well-known types and binary lookup for other types.
            </summary>
        </member>
        <member name="T:Spreads.Buffers.PinnedArrayMemorySliceBucket`1">
            <summary>
            Used in <see cref="T:Spreads.Buffers.RetainableMemoryPool`1"/> for pinned memory less than LOH size.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Spreads.Buffers.ArrayMemory`1.Create(System.Int32,System.Boolean)">
            <summary>
            Create <see cref="T:Spreads.Buffers.ArrayMemory`1"/> backed by an array from shared array pool.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.ArrayMemory`1.Create(`0[],System.Boolean,System.Boolean)">
            <summary>
            Create <see cref="T:Spreads.Buffers.ArrayMemory`1"/> backed by the provided array.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.ArrayMemory`1.Create(`0[],System.Int32,System.Int32,System.Boolean,System.Boolean,Spreads.Buffers.RetainableMemoryPool{`0})">
            <summary>
            Create <see cref="T:Spreads.Buffers.ArrayMemory`1"/> backed by the provided array.
            </summary>
        </member>
        <member name="P:Spreads.Buffers.ArrayMemory`1.Vec">
            <summary>
            Returns <see cref="T:Spreads.Native.Vec`1"/> backed by this instance memory.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.BufferPool`1.Return(`0[],System.Boolean)">
            <summary>
            Return an array to the pool.
            </summary>
            <param name="array">An array to return.</param>
            <param name="clearArray">Force clear of arrays of blittable types. Arrays that could have references are always cleared.</param>
        </member>
        <member name="F:Spreads.Buffers.BufferPool.OffHeapMemoryPool">
            <summary>
            Default OffHeap pool has capacity of 4 + Environment.ProcessorCount. This static field could be changed to a new instance.
            Buffers are never cleared automatically and user must clear them when needed. Zeroing is a big cost
            and even new[]-ing has to zero memory, this is why it is slow.
            Please know what you are doing.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.BufferPool.Retain(System.Int32,System.Boolean)">
            <summary>
            Return a contiguous segment of memory backed by a pooled memory from a shares array pool.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.BufferPool.RetainTemp(System.Int32)">
            <summary>
            Retains memory for temporary usage. Actual length could be larger than requested.
            When requested length is above 64kb then off-heap memory is used.
            </summary>
        </member>
        <member name="T:Spreads.Buffers.BuffersThrowHelper">
            <summary>
            Buffers throw helper
            </summary>
        </member>
        <member name="T:Spreads.Buffers.BufferWriter">
            <summary>
            Unsafe fast buffer writer.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.BufferWriter.Write``1(``0@)">
            <summary>
            Ensures capacity and writes an unmanaged structure <paramref name="value"/> at current offset.
            Type <typeparamref name="T"/> is not checked in release mode. This is equivalent of calling
            <see cref="M:System.Runtime.CompilerServices.Unsafe.WriteUnaligned``1(System.Byte@,``0)"/>.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.BufferWriter.DangerousWriteAtOffset``1(``0,System.Int32)">
            <summary>
            Write at custom offset. Could overwrite data in already written segment.
            Usually this is the intent when using this method but be very careful.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.BufferWriter.Write(Spreads.Buffers.DirectBuffer)">
            <summary>
            Ensures capacity for and writes the entire content of <paramref name="buffer"/>.
            Returns the number of bytes written, which must equal to <paramref name="buffer"/> length.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.BufferWriter.WriteSpan(System.ReadOnlySpan{System.Byte})">
            <summary>
            Ensures capacity for and writes the entire content of <paramref name="span"/>.
            Returns the number of bytes written, which must equal to <paramref name="span"/> length.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.BufferWriter.Write(System.Byte@,System.UInt32)">
            <summary>
            Ensures capacity and writes <paramref name="length"/> number of bytes starting from <paramref name="source"/> byte reference.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.BufferWriter.Advance(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.Buffers.BufferWriter.GetMemory(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.Buffers.BufferWriter.GetSpan(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.Buffers.BufferWriter.DetachMemory">
            <summary>
            Returns <see cref="P:Spreads.Buffers.BufferWriter.WrittenMemory"/> as <see cref="T:Spreads.Buffers.RetainedMemory`1"/> and disposes this <see cref="T:Spreads.Buffers.BufferWriter"/>.
            The returned memory must be disposed after processing.
            </summary>
        </member>
        <member name="T:Spreads.Buffers.DirectBuffer">
            <summary>
            Provides unsafe read/write operations on a memory pointer.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.#ctor(System.Int64,System.IntPtr)">
            <summary>
            Attach a view to an unmanaged buffer owned by external code
            </summary>
            <param name="data">Unmanaged byte buffer</param>
            <param name="length">Length of the buffer</param>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.#ctor(System.Int64,System.Byte*)">
            <summary>
            Unsafe constructors performs no input checks.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.ReadChar(System.Int64)">
            <summary>
            Gets the <see cref="T:System.Byte"/> value at a given index.
            </summary>
            <param name="index">index in bytes from which to get.</param>
            <returns>the value at a given index.</returns>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.WriteChar(System.Int64,System.Char)">
            <summary>
            Writes a <see cref="T:System.Byte"/> value to a given index.
            </summary>
            <param name="index">index in bytes for where to put.</param>
            <param name="value">value to be written</param>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.ReadSByte(System.Int64)">
            <summary>
            Gets the <see cref="T:System.SByte"/> value at a given index.
            </summary>
            <param name="index"> index in bytes from which to get.</param>
            <returns>the value at a given index.</returns>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.WriteSByte(System.Int64,System.SByte)">
            <summary>
            Writes a <see cref="T:System.SByte"/> value to a given index.
            </summary>
            <param name="index">index in bytes for where to put.</param>
            <param name="value">value to be written</param>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.ReadByte(System.Int64)">
            <summary>
            Gets the <see cref="T:System.Byte"/> value at a given index.
            </summary>
            <param name="index"> index in bytes from which to get.</param>
            <returns>the value at a given index.</returns>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.WriteByte(System.Int64,System.Byte)">
            <summary>
            Writes a <see cref="T:System.Byte"/> value to a given index.
            </summary>
            <param name="index">index in bytes for where to put.</param>
            <param name="value">value to be written</param>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.ReadInt16(System.Int64)">
            <summary>
            Gets the <see cref="T:System.Int16"/> value at a given index.
            </summary>
            <param name="index"> index in bytes from which to get.</param>
            <returns>the value at a given index.</returns>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.WriteInt16(System.Int64,System.Int16)">
            <summary>
            Writes a <see cref="T:System.Int16"/> value to a given index.
            </summary>
            <param name="index">index in bytes for where to put.</param>
            <param name="value">value to be written</param>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.ReadInt32(System.Int64)">
            <summary>
            Gets the <see cref="T:System.Int32"/> value at a given index.
            </summary>
            <param name="index"> index in bytes from which to get.</param>
            <returns>the value at a given index.</returns>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.WriteInt32(System.Int64,System.Int32)">
            <summary>
            Writes a <see cref="T:System.Int32"/> value to a given index.
            </summary>
            <param name="index">index in bytes for where to put.</param>
            <param name="value">value to be written</param>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.ReadInt64(System.Int64)">
            <summary>
            Gets the <see cref="T:System.Int64"/> value at a given index.
            </summary>
            <param name="index"> index in bytes from which to get.</param>
            <returns>the value at a given index.</returns>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.WriteInt64(System.Int64,System.Int64)">
            <summary>
            Writes a <see cref="T:System.Int64"/> value to a given index.
            </summary>
            <param name="index">index in bytes for where to put.</param>
            <param name="value">value to be written</param>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.ReadUInt16(System.Int64)">
            <summary>
            Gets the <see cref="T:System.UInt16"/> value at a given index.
            </summary>
            <param name="index"> index in bytes from which to get.</param>
            <returns>the value at a given index.</returns>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.WriteUInt16(System.Int64,System.UInt16)">
            <summary>
            Writes a <see cref="T:System.UInt16"/> value to a given index.
            </summary>
            <param name="index">index in bytes for where to put.</param>
            <param name="value">value to be written</param>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.ReadUInt32(System.Int64)">
            <summary>
            Gets the <see cref="T:System.UInt32"/> value at a given index.
            </summary>
            <param name="index"> index in bytes from which to get.</param>
            <returns>the value at a given index.</returns>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.WriteUInt32(System.Int64,System.UInt32)">
            <summary>
            Writes a <see cref="T:System.UInt32"/> value to a given index.
            </summary>
            <param name="index">index in bytes for where to put.</param>
            <param name="value">value to be written</param>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.ReadUInt64(System.Int64)">
            <summary>
            Gets the <see cref="T:System.UInt64"/> value at a given index.
            </summary>
            <param name="index"> index in bytes from which to get.</param>
            <returns>the value at a given index.</returns>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.WriteUInt64(System.Int64,System.UInt64)">
            <summary>
            Writes a <see cref="T:System.UInt64"/> value to a given index.
            </summary>
            <param name="index">index in bytes for where to put.</param>
            <param name="value">value to be written</param>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.ReadFloat(System.Int64)">
            <summary>
            Gets the <see cref="T:System.Single"/> value at a given index.
            </summary>
            <param name="index"> index in bytes from which to get.</param>
            <returns>the value at a given index.</returns>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.WriteFloat(System.Int64,System.Single)">
            <summary>
            Writes a <see cref="T:System.Single"/> value to a given index.
            </summary>
            <param name="index">index in bytes for where to put.</param>
            <param name="value">value to be written</param>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.ReadDouble(System.Int64)">
            <summary>
            Gets the <see cref="T:System.Double"/> value at a given index.
            </summary>
            <param name="index"> index in bytes from which to get.</param>
            <returns>the value at a given index.</returns>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.WriteDouble(System.Int64,System.Double)">
            <summary>
            Writes a <see cref="T:System.Double"/> value to a given index.
            </summary>
            <param name="index">index in bytes for where to put.</param>
            <param name="value">value to be written</param>
        </member>
        <member name="M:Spreads.Buffers.DirectBuffer.Read``1(System.Int64)">
            <summary>
            Unaligned read starting from index.
            A shortcut to <see cref="M:System.Runtime.CompilerServices.Unsafe.ReadUnaligned``1(System.Void*)"/>.
            </summary>
        </member>
        <member name="T:Spreads.Buffers.IPinnedSpan`1">
            <summary>
            Helper interface to simplify work with pinned/native memory without relying only on Span.
            </summary>
            <typeparam name="T">Unmanaged struct yet without C# 7.3 `unmanaged` constraint.</typeparam>
        </member>
        <member name="P:Spreads.Buffers.IPinnedSpan`1.Data">
            <summary>
            Pointer to the first element.
            </summary>
        </member>
        <member name="P:Spreads.Buffers.IPinnedSpan`1.Length">
            <summary>
            Number of items (not bytes when T != byte)
            </summary>
        </member>
        <member name="T:Spreads.Buffers.OffHeapBuffer`1">
            <summary>
            Completely not thread-safe with possible segfaults if created/resized from different threads.
            </summary>
        </member>
        <member name="F:Spreads.Buffers.OffHeapBuffer`1._pointer">
            <summary>
            Use only after EnsureCapacity call
            </summary>
        </member>
        <member name="P:Spreads.Buffers.OffHeapBuffer`1.Length">
            <inheritdoc />
        </member>
        <member name="P:Spreads.Buffers.OffHeapBuffer`1.IsEmpty">
            <inheritdoc />
        </member>
        <member name="P:Spreads.Buffers.OffHeapBuffer`1.DirectBuffer">
            <inheritdoc />
        </member>
        <member name="P:Spreads.Buffers.OffHeapBuffer`1.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Spreads.Buffers.RecyclableMemoryStream">
             <summary>
             MemoryStream implementation that deals with pooling and managing memory streams which use potentially large
             buffers.
             </summary>
             <remarks>
             This class works in tandem with the RecylableMemoryStreamManager to supply MemoryStream
             objects to callers, while avoiding these specific problems:
             1. LOH allocations - since all large buffers are pooled, they will never incur a Gen2 GC
             2. Memory waste - A standard memory stream doubles its size when it runs out of room. This
             leads to continual memory growth as each stream approaches the maximum allowed size.
             3. Memory copying - Each time a MemoryStream grows, all the bytes are copied into new buffers.
             This implementation only copies the bytes when GetBuffer is called.
             4. Memory fragmentation - By using homogeneous buffer sizes, it ensures that blocks of memory
             can be easily reused.
            
             The stream is implemented on top of a series of uniformly-sized blocks. As the stream's length grows,
             additional blocks are retrieved from the memory manager. It is these blocks that are pooled, not the stream
             object itself.
            
             The biggest wrinkle in this implementation is when GetBuffer() is called. This requires a single
             contiguous buffer. If only a single block is in use, then that block is returned. If multiple blocks
             are in use, we retrieve a larger buffer from the memory manager. These large buffers are also pooled,
             split by size--they are multiples of a chunk size (1 MB by default).
            
             Once a large buffer is assigned to the stream the blocks are NEVER again used for this stream. All operations take place on the
             large buffer. The large buffer can be replaced by a larger buffer from the pool as needed. All blocks and large buffers
             are maintained in the stream until the stream is disposed (unless AggressiveBufferReturn is enabled in the stream manager).
            
             </remarks>
        </member>
        <member name="F:Spreads.Buffers.RecyclableMemoryStream._blocks">
            <summary>
            All of these blocks must be the same size
            </summary>
        </member>
        <member name="F:Spreads.Buffers.RecyclableMemoryStream._largeBuffer">
            <summary>
            This is only set by GetBuffer() if the necessary buffer is larger than a single block size, or on
            construction if the caller immediately requests a single large buffer.
            </summary>
            <remarks>If this field is non-null, it contains the concatenation of the bytes found in the individual
            blocks. Once it is created, this (or a larger) largeBuffer will be used for the life of the stream.
            </remarks>
        </member>
        <member name="P:Spreads.Buffers.RecyclableMemoryStream.Id">
            <summary>
            Unique identifier for this stream across it's entire lifetime
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="P:Spreads.Buffers.RecyclableMemoryStream.Tag">
            <summary>
            A temporary identifier for the current usage of this stream.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="P:Spreads.Buffers.RecyclableMemoryStream.MemoryManager">
            <summary>
            Gets the memory manager being used by this stream.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="P:Spreads.Buffers.RecyclableMemoryStream.AllocationStack">
            <summary>
            Callstack of the constructor. It is only set if MemoryManager.GenerateCallStacks is true,
            which should only be in debugging situations.
            </summary>
        </member>
        <member name="P:Spreads.Buffers.RecyclableMemoryStream.DisposeStack">
            <summary>
            Callstack of the Dispose call. It is only set if MemoryManager.GenerateCallStacks is true,
            which should only be in debugging situations.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStream.Create(System.Int32,System.Byte[],System.Int32,System.String,Spreads.Buffers.RecyclableMemoryStreamManager)">
            <summary>
            Allocate a new RecyclableMemoryStream object
            </summary>
            <param name="requestedSize">The initial requested size to prevent future allocations</param>
            <param name="initialLargeBuffer">An initial buffer to use. This buffer will be owned by the stream and returned to the memory manager upon Dispose.</param>
            <param name="length">Set length if initialLargeBuffer has data.</param>
            <param name="tag">A string identifying this stream for logging and debugging purposes</param>
            <param name="memoryManager">The memory manager</param>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStream.Create(Spreads.Buffers.RecyclableMemoryStreamManager)">
            <summary>
            Allocate a new RecyclableMemoryStream object.
            </summary>
            <param name="memoryManager">The memory manager</param>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStream.Create(Spreads.Buffers.RecyclableMemoryStreamManager,System.String)">
            <summary>
            Allocate a new RecyclableMemoryStream object
            </summary>
            <param name="memoryManager">The memory manager</param>
            <param name="tag">A string identifying this stream for logging and debugging purposes</param>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStream.Create(System.Int32,System.String,Spreads.Buffers.RecyclableMemoryStreamManager)">
            <summary>
            Allocate a new RecyclableMemoryStream object
            </summary>
            <param name="requestedSize">The initial requested size to prevent future allocations</param>
            <param name="tag">A string identifying this stream for logging and debugging purposes</param>
            <param name="memoryManager">The memory manager</param>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStream.Dispose(System.Boolean)">
            <summary>
            Returns the memory used by this stream back to the pool.
            </summary>
            <param name="disposing">Whether we're disposing (true), or being called by the finalizer (false)</param>
            <remarks>This method is not thread safe and it may not be called more than once.</remarks>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStream.Close">
            <summary>
            Equivalent to Dispose
            </summary>
        </member>
        <member name="P:Spreads.Buffers.RecyclableMemoryStream.Capacity">
            <summary>
            Gets or sets the capacity
            </summary>
            <remarks>Capacity is always in multiples of the memory manager's block size, unless
            the large buffer is in use.  Capacity never decreases during a stream's lifetime.
            Explicitly setting the capacity to a lower value than the current value will have no effect.
            This is because the buffers are all pooled by chunks and there's little reason to
            allow stream truncation.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="P:Spreads.Buffers.RecyclableMemoryStream.Length">
            <summary>
            Gets the number of bytes written to this stream.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="P:Spreads.Buffers.RecyclableMemoryStream.Position">
            <summary>
            Gets the current position in the stream
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="P:Spreads.Buffers.RecyclableMemoryStream.CanRead">
            <summary>
            Whether the stream can currently read
            </summary>
        </member>
        <member name="P:Spreads.Buffers.RecyclableMemoryStream.CanSeek">
            <summary>
            Whether the stream can currently seek
            </summary>
        </member>
        <member name="P:Spreads.Buffers.RecyclableMemoryStream.CanTimeout">
            <summary>
            Always false
            </summary>
        </member>
        <member name="P:Spreads.Buffers.RecyclableMemoryStream.CanWrite">
            <summary>
            Whether the stream can currently write
            </summary>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStream.GetBuffer">
            <summary>
            Returns a single buffer containing the contents of the stream.
            The buffer may be longer than the stream length.
            </summary>
            <returns>A byte[] buffer</returns>
            <remarks>IMPORTANT: Doing a Write() after calling GetBuffer() invalidates the buffer. The old buffer is held onto
            until Dispose is called, but the next time GetBuffer() is called, a new buffer from the pool will be required.</remarks>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStream.ToArray">
            <summary>
            Returns a new array with a copy of the buffer's contents. You should almost certainly be using GetBuffer combined with the Length to
            access the bytes in this stream. Calling ToArray will destroy the benefits of pooled buffers, but it is included
            for the sake of completeness.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads from the current position into the provided buffer
            </summary>
            <param name="buffer">Destination buffer</param>
            <param name="offset">Offset into buffer at which to start placing the read bytes.</param>
            <param name="count">Number of bytes to read.</param>
            <returns>The number of bytes read</returns>
            <exception cref="T:System.ArgumentNullException">buffer is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is less than 0</exception>
            <exception cref="T:System.ArgumentException">offset subtracted from the buffer length is less than count</exception>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStream.SafeRead(System.Byte[],System.Int64,System.Int64,System.Int64@)">
            <summary>
            Reads from the specified position into the provided buffer
            </summary>
            <param name="buffer">Destination buffer</param>
            <param name="offset">Offset into buffer at which to start placing the read bytes.</param>
            <param name="count">Number of bytes to read.</param>
            <param name="streamPosition">Position in the stream to start reading from</param>
            <returns>The number of bytes read</returns>
            <exception cref="T:System.ArgumentNullException">buffer is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is less than 0</exception>
            <exception cref="T:System.ArgumentException">offset subtracted from the buffer length is less than count</exception>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the buffer to the stream
            </summary>
            <param name="buffer">Source buffer</param>
            <param name="offset">Start position</param>
            <param name="count">Number of bytes to write</param>
            <exception cref="T:System.ArgumentNullException">buffer is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative</exception>
            <exception cref="T:System.ArgumentException">buffer.Length - offset is not less than count</exception>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStream.SafeWrite(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the buffer to the stream
            </summary>
            <param name="buffer">Source buffer</param>
            <param name="offset">Start position</param>
            <param name="count">Number of bytes to write</param>
            <exception cref="T:System.ArgumentNullException">buffer is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative</exception>
            <exception cref="T:System.ArgumentException">buffer.Length - offset is not less than count</exception>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStream.ToString">
            <summary>
            Returns a useful string for debugging. This should not normally be called in actual production code.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStream.WriteByte(System.Byte)">
            <summary>
            Writes a single byte to the current position in the stream.
            </summary>
            <param name="value">byte value to write</param>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStream.SafeWriteByte(System.Byte)">
            <summary>
            Writes a single byte to the current position in the stream.
            </summary>
            <param name="value">byte value to write</param>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStream.ReadByte">
            <summary>
            Reads a single byte from the current position in the stream.
            </summary>
            <returns>The byte at the current position, or -1 if the position is at the end of the stream.</returns>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStream.SafeReadByte(System.Int64@)">
            <summary>
            Reads a single byte from the specified position in the stream.
            </summary>
            <param name="streamPosition">The position in the stream to read from</param>
            <returns>The byte at the current position, or -1 if the position is at the end of the stream.</returns>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStream.SetLength(System.Int64)">
            <summary>
            Sets the length of the stream
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">value is negative or larger than MaxStreamLength</exception>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position to the offset from the seek location
            </summary>
            <param name="offset">How many bytes to move</param>
            <param name="loc">From where</param>
            <returns>The new position</returns>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset is larger than MaxStreamLength</exception>
            <exception cref="T:System.ArgumentException">Invalid seek origin</exception>
            <exception cref="T:System.IO.IOException">Attempt to set negative position</exception>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStream.WriteTo(System.IO.Stream)">
            <summary>
            Synchronously writes this stream's bytes to the parameter stream.
            </summary>
            <param name="stream">Destination stream</param>
            <remarks>Important: This does a synchronous write, which may not be desired in some situations</remarks>
        </member>
        <member name="P:Spreads.Buffers.RecyclableMemoryStream.Chunks">
            <summary>
            Iterate over all internal chunks as ArraySegments without copying data
            </summary>
        </member>
        <member name="T:Spreads.Buffers.RecyclableMemoryStreamManager">
             <summary>
             Manages pools of RecyclableMemoryStream objects.
             </summary>
             <remarks>
             There are two pools managed in here. The small pool contains same-sized buffers that are handed to streams
             as they write more data.
            
             For scenarios that need to call GetBuffer(), the large pool contains buffers of various sizes, all
             multiples of LargeBufferMultiple (1 MB by default). They are split by size to avoid overly-wasteful buffer
             usage. There should be far fewer 8 MB buffers than 1 MB buffers, for example.
             </remarks>
        </member>
        <member name="T:Spreads.Buffers.RecyclableMemoryStreamManager.EventHandler">
            <summary>
            Generic delegate for handling events without any arguments.
            </summary>
        </member>
        <member name="T:Spreads.Buffers.RecyclableMemoryStreamManager.LargeBufferDiscardedEventHandler">
            <summary>
            Delegate for handling large buffer discard reports.
            </summary>
            <param name="reason">Reason the buffer was discarded.</param>
        </member>
        <member name="T:Spreads.Buffers.RecyclableMemoryStreamManager.StreamLengthReportHandler">
            <summary>
            Delegate for handling reports of stream size when streams are allocated
            </summary>
            <param name="bytes">Bytes allocated.</param>
        </member>
        <member name="T:Spreads.Buffers.RecyclableMemoryStreamManager.UsageReportEventHandler">
            <summary>
            Delegate for handling periodic reporting of memory use statistics.
            </summary>
            <param name="smallPoolInUseBytes">Bytes currently in use in the small pool.</param>
            <param name="smallPoolFreeBytes">Bytes currently free in the small pool.</param>
            <param name="largePoolInUseBytes">Bytes currently in use in the large pool.</param>
            <param name="largePoolFreeBytes">Bytes currently free in the large pool.</param>
        </member>
        <member name="F:Spreads.Buffers.RecyclableMemoryStreamManager._largePools">
            <summary>
            pools[0] = 1x largeBufferMultiple buffers
            pools[1] = 2x largeBufferMultiple buffers
            etc., up to maximumBufferSize
            </summary>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStreamManager.#ctor">
            <summary>
            Initializes the memory manager with the default block/buffer specifications.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStreamManager.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes the memory manager with the given block requiredSize.
            </summary>
            <param name="blockSize">Size of each block that is pooled. Must be > 0. Will use the next power of two if the given size in not a power of two.</param>
            <param name="largeBufferMultiple">Each large buffer will be a multiple of this value.</param>
            <param name="maximumBufferSize">Buffers larger than this are not pooled</param>
            <exception cref="T:System.ArgumentOutOfRangeException">blockSize is not a positive number, or largeBufferMultiple is not a positive number, or maximumBufferSize is less than blockSize.</exception>
            <exception cref="T:System.ArgumentException">maximumBufferSize is not a multiple of largeBufferMultiple</exception>
        </member>
        <member name="P:Spreads.Buffers.RecyclableMemoryStreamManager.BlockSize">
            <summary>
            The size of each block. It must be set at creation and cannot be changed.
            </summary>
        </member>
        <member name="P:Spreads.Buffers.RecyclableMemoryStreamManager.LargeBufferMultiple">
            <summary>
            All buffers are multiples of this number. It must be set at creation and cannot be changed.
            </summary>
        </member>
        <member name="P:Spreads.Buffers.RecyclableMemoryStreamManager.MaximumBufferSize">
            <summary>
            Gets or sets the maximum buffer size.
            </summary>
            <remarks>Any buffer that is returned to the pool that is larger than this will be
            discarded and garbage collected.</remarks>
        </member>
        <member name="P:Spreads.Buffers.RecyclableMemoryStreamManager.LargePoolFreeSize">
            <summary>
            Number of bytes in large pool not currently in use
            </summary>
        </member>
        <member name="P:Spreads.Buffers.RecyclableMemoryStreamManager.LargePoolInUseSize">
            <summary>
            Number of bytes currently in use by streams from the large pool
            </summary>
        </member>
        <member name="P:Spreads.Buffers.RecyclableMemoryStreamManager.LargeBuffersFree">
            <summary>
            How many buffers are in the large pool
            </summary>
        </member>
        <member name="P:Spreads.Buffers.RecyclableMemoryStreamManager.MaximumFreeLargePoolBytes">
            <summary>
            How many bytes of large free buffers to allow before we start dropping
            those returned to us.
            </summary>
        </member>
        <member name="P:Spreads.Buffers.RecyclableMemoryStreamManager.MaximumStreamCapacity">
            <summary>
            Maximum stream capacity in bytes. Attempts to set a larger capacity will
            result in an exception.
            </summary>
            <remarks>A value of 0 indicates no limit.</remarks>
        </member>
        <member name="P:Spreads.Buffers.RecyclableMemoryStreamManager.GenerateCallStacks">
            <summary>
            Whether to save callstacks for stream allocations. This can help in debugging.
            It should NEVER be turned on generally in production.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStreamManager.GetBlock">
            <summary>
            Removes and returns a single block from the pool.
            </summary>
            <returns>A byte[] array</returns>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStreamManager.GetLargeBuffer(System.Int32,System.String)">
            <summary>
            Returns a buffer of arbitrary size from the large buffer pool. This buffer
            will be at least the requiredSize and always be a multiple of largeBufferMultiple.
            </summary>
            <param name="requiredSize">The minimum length of the buffer</param>
            <param name="tag">The tag of the stream returning this buffer, for logging if necessary.</param>
            <returns>A buffer of at least the required size.</returns>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStreamManager.ReturnLargeBuffer(System.Byte[],System.String)">
            <summary>
            Returns the buffer to the large pool
            </summary>
            <param name="buffer">The buffer to return.</param>
            <param name="tag">The tag of the stream returning this buffer, for logging if necessary.</param>
            <exception cref="T:System.ArgumentNullException">buffer is null</exception>
            <exception cref="T:System.ArgumentException">buffer.Length is not a multiple of LargeBufferMultiple (it did not originate from this pool)</exception>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStreamManager.ReturnBlocks(System.Collections.Generic.List{System.Byte[]},System.String)">
            <summary>
            Returns the blocks to the pool
            </summary>
            <param name="blocks">Collection of blocks to return to the pool</param>
            <param name="tag">The tag of the stream returning these blocks, for logging if necessary.</param>
            <exception cref="T:System.ArgumentNullException">blocks is null</exception>
            <exception cref="T:System.ArgumentException">blocks contains buffers that are the wrong size (or null) for this memory manager</exception>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStreamManager.GetStream">
            <summary>
            Retrieve a new MemoryStream object with no tag and a default initial capacity.
            </summary>
            <returns>A MemoryStream.</returns>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStreamManager.GetStream(System.String)">
            <summary>
            Retrieve a new MemoryStream object with the given tag and a default initial capacity.
            </summary>
            <param name="tag">A tag which can be used to track the source of the stream.</param>
            <returns>A MemoryStream.</returns>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStreamManager.GetStream(System.String,System.Int32)">
            <summary>
            Retrieve a new MemoryStream object with the given tag and at least the given capacity.
            </summary>
            <param name="tag">A tag which can be used to track the source of the stream.</param>
            <param name="requiredSize">The minimum desired capacity for the stream.</param>
            <returns>A MemoryStream.</returns>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStreamManager.GetStream(System.String,System.Int32,System.Boolean)">
            <summary>
            Retrieve a new MemoryStream object with the given tag and at least the given capacity, possibly using
            a single continugous underlying buffer.
            </summary>
            <remarks>Retrieving a MemoryStream which provides a single contiguous buffer can be useful in situations
            where the initial size is known and it is desirable to avoid copying data between the smaller underlying
            buffers to a single large one. This is most helpful when you know that you will always call GetBuffer
            on the underlying stream.</remarks>
            <param name="tag">A tag which can be used to track the source of the stream.</param>
            <param name="requiredSize">The minimum desired capacity for the stream.</param>
            <param name="asContiguousBuffer">Whether to attempt to use a single contiguous buffer.</param>
            <returns>A MemoryStream.</returns>
        </member>
        <member name="M:Spreads.Buffers.RecyclableMemoryStreamManager.GetStream(System.String,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Retrieve a new MemoryStream object with the given tag and with contents copied from the provided
            buffer. The provided buffer is not wrapped or used after construction.
            </summary>
            <remarks>The new stream's position is set to the beginning of the stream when returned.</remarks>
            <param name="tag">A tag which can be used to track the source of the stream.</param>
            <param name="buffer">The byte buffer to copy data from.</param>
            <param name="offset">The offset from the start of the buffer to copy from.</param>
            <param name="count">The number of bytes to copy from the buffer.</param>
            <returns>A MemoryStream.</returns>
        </member>
        <member name="E:Spreads.Buffers.RecyclableMemoryStreamManager.BlockCreated">
            <summary>
            Triggered when a new block is created.
            </summary>
        </member>
        <member name="E:Spreads.Buffers.RecyclableMemoryStreamManager.BlockDiscarded">
            <summary>
            Triggered when a new block is created.
            </summary>
        </member>
        <member name="E:Spreads.Buffers.RecyclableMemoryStreamManager.LargeBufferCreated">
            <summary>
            Triggered when a new large buffer is created.
            </summary>
        </member>
        <member name="E:Spreads.Buffers.RecyclableMemoryStreamManager.StreamCreated">
            <summary>
            Triggered when a new stream is created.
            </summary>
        </member>
        <member name="E:Spreads.Buffers.RecyclableMemoryStreamManager.StreamDisposed">
            <summary>
            Triggered when a stream is disposed.
            </summary>
        </member>
        <member name="E:Spreads.Buffers.RecyclableMemoryStreamManager.StreamFinalized">
            <summary>
            Triggered when a stream is finalized.
            </summary>
        </member>
        <member name="E:Spreads.Buffers.RecyclableMemoryStreamManager.StreamLength">
            <summary>
            Triggered when a stream is finalized.
            </summary>
        </member>
        <member name="E:Spreads.Buffers.RecyclableMemoryStreamManager.StreamConvertedToArray">
            <summary>
            Triggered when a user converts a stream to array.
            </summary>
        </member>
        <member name="E:Spreads.Buffers.RecyclableMemoryStreamManager.LargeBufferDiscarded">
            <summary>
            Triggered when a large buffer is discarded, along with the reason for the discard.
            </summary>
        </member>
        <member name="E:Spreads.Buffers.RecyclableMemoryStreamManager.UsageReport">
            <summary>
            Periodically triggered to report usage statistics.
            </summary>
        </member>
        <member name="T:Spreads.Buffers.RetainableMemory`1">
            <summary>
            Base class for retainable memory from a pool of arrays or from native memory.
            </summary>
        </member>
        <member name="F:Spreads.Buffers.RetainableMemory`1.PoolIndex">
            <summary>
            0 - externally owned;
            1 - default array pool (no RM pool);
            2+ - custom pool.
            </summary>
        </member>
        <member name="F:Spreads.Buffers.RetainableMemory`1.IsPooled">
            <summary>
            A pool sets this value atomically from inside a lock.
            </summary>
        </member>
        <member name="F:Spreads.Buffers.RetainableMemory`1.SkipCleaning">
            <summary>
            True if the memory is already clean (all zeros) on return. Useful for the case when
            the pool has <see cref="F:Spreads.Buffers.RetainableMemoryPool`1.IsRentAlwaysClean"/> set to true
            but we know that the buffer is already clean. Use with caution only when cleanliness
            is obvious and when cost of cleaning could be high (larger buffers).
            </summary>
        </member>
        <member name="F:Spreads.Buffers.RetainableMemory`1.IsNativeWithHeader">
            <summary>
            True if there is a header at <see cref="F:Spreads.Buffers.RetainableMemory`1.NativeHeaderSize"/> before the <see cref="P:Spreads.Buffers.RetainableMemory`1.Pointer"/>.
            Special case for DataSpreads SM.
            </summary>
        </member>
        <member name="F:Spreads.Buffers.RetainableMemory`1.NativeHeaderSize">
            <summary>
            DataSpreads shared memory header before <see cref="P:Spreads.Buffers.RetainableMemory`1.Pointer"/>.
            </summary>
        </member>
        <member name="P:Spreads.Buffers.RetainableMemory`1.ExternallyOwned">
            <summary>
            An array was allocated manually. Otherwise even if _pool == null we return the array to default array pool on Dispose.
            </summary>
        </member>
        <member name="P:Spreads.Buffers.RetainableMemory`1.PointerPow2">
            <summary>
            Extra space (if any) is at the beginning.
            </summary>
        </member>
        <member name="P:Spreads.Buffers.RetainableMemory`1.IsPinned">
            <summary>
            The underlying memory is a pinned array or native memory.
            </summary>
        </member>
        <member name="P:Spreads.Buffers.RetainableMemory`1.IsRetained">
            <summary>
            <see cref="P:Spreads.Buffers.RetainableMemory`1.ReferenceCount"/> is positive, i.e. the memory is retained (borrowed).
            </summary>
        </member>
        <member name="P:Spreads.Buffers.RetainableMemory`1.LengthPow2">
            <summary>
            Length for pool buckets. To simplify and speedup implementation we just
            use default pow2 pool logic without virtual methods and complexity of
            calculating lengths. A buffer is pooled by max pow2 it could fit into.
            </summary>
        </member>
        <member name="P:Spreads.Buffers.RetainableMemory`1.Vec">
            <summary>
            Returns <see cref="T:Spreads.Native.Vec`1"/> backed by the memory of this instance.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.RetainableMemory`1.Retain">
            <summary>
            Retain buffer memory.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.RetainableMemory`1.Retain(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Retain buffer memory without pinning it.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.RetainableMemory`1.Finalize">
            <summary>
            We need a finalizer because reference count and backing memory could be a native resource.
            If object dies without releasing a reference then it is an error.
            Current code kills application by throwing in finalizer and this is what we want
            for DS - ensure correct memory management.
            </summary>
        </member>
        <member name="T:Spreads.Buffers.RetainableMemoryPool`1">
            <summary>
            A custom <see cref="T:System.Buffers.MemoryPool`1"/> implementation.
            </summary>
        </member>
        <member name="F:Spreads.Buffers.RetainableMemoryPool`1.IsRentAlwaysClean">
            <summary>
            Set to true to always clean on return and clean buffers produced by the factory provided to the constructor.
            </summary>
        </member>
        <member name="F:Spreads.Buffers.RetainableMemoryPool`1.DefaultMaxArrayLength">
            <summary>The default maximum length of each array in the pool (2^20).</summary>
        </member>
        <member name="F:Spreads.Buffers.RetainableMemoryPool`1.DefaultMaxNumberOfArraysPerBucket">
            <summary>The default maximum number of arrays per bucket that are available for rent.</summary>
        </member>
        <member name="P:Spreads.Buffers.RetainableMemoryPool`1.Id">
            <summary>
            Gets an ID for the pool to use with events.
            </summary>
            <remarks>
            <see cref="F:Spreads.Buffers.RetainableMemoryPool`1.PoolIdx"/> is per type.
            </remarks>
        </member>
        <member name="T:Spreads.Buffers.RetainableMemoryPool`1.Bucket">
            <summary>Provides a thread-safe bucket containing buffers that can be Rent'd and Return'd.</summary>
        </member>
        <member name="F:Spreads.Buffers.RetainableMemoryPool`1.Bucket._pinnedSliceBucket">
            <summary>
            Used for pinned slices
            </summary>
        </member>
        <member name="M:Spreads.Buffers.RetainableMemoryPool`1.Bucket.#ctor(Spreads.Buffers.RetainableMemoryPool{`0},System.Func{Spreads.Buffers.RetainableMemoryPool{`0},System.Int32,Spreads.Buffers.RetainableMemory{`0}},System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates the pool with numberOfBuffers buffers where each buffer is of bufferLength length.
            </summary>
        </member>
        <member name="P:Spreads.Buffers.RetainableMemoryPool`1.Bucket.Id">
            <summary>Gets an ID for the bucket to use with events.</summary>
        </member>
        <member name="M:Spreads.Buffers.RetainableMemoryPool`1.Bucket.Rent">
            <summary>Takes an array from the bucket.  If the bucket is empty, returns null.</summary>
        </member>
        <member name="T:Spreads.Buffers.RetainableMemoryPoolEventSource.BufferAllocatedReason">
            <summary>The reason for a BufferAllocated event.</summary>
        </member>
        <member name="F:Spreads.Buffers.RetainableMemoryPoolEventSource.BufferAllocatedReason.Pooled">
            <summary>The pool is allocating a buffer to be pooled in a bucket.</summary>
        </member>
        <member name="F:Spreads.Buffers.RetainableMemoryPoolEventSource.BufferAllocatedReason.OverMaximumSize">
            <summary>The requested buffer size was too large to be pooled.</summary>
        </member>
        <member name="F:Spreads.Buffers.RetainableMemoryPoolEventSource.BufferAllocatedReason.PoolExhausted">
            <summary>The pool has already allocated for pooling as many buffers of a particular size as it's allowed.</summary>
        </member>
        <member name="M:Spreads.Buffers.RetainableMemoryPoolEventSource.BufferRented(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Event for when a buffer is rented.  This is invoked once for every successful call to Rent,
            regardless of whether a buffer is allocated or a buffer is taken from the pool.  In a
            perfect situation where all rented buffers are returned, we expect to see the number
            of BufferRented events exactly match the number of BuferReturned events, with the number
            of BufferAllocated events being less than or equal to those numbers (ideally significantly
            less than).
            </summary>
        </member>
        <member name="M:Spreads.Buffers.RetainableMemoryPoolEventSource.BufferAllocated(System.Int32,System.Int32,System.Int32,System.Int32,Spreads.Buffers.RetainableMemoryPoolEventSource.BufferAllocatedReason)">
            <summary>
            Event for when a buffer is allocated by the pool.  In an ideal situation, the number
            of BufferAllocated events is significantly smaller than the number of BufferRented and
            BufferReturned events.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.RetainableMemoryPoolEventSource.BufferReturned(System.Int32,System.Int32,System.Int32)">
            <summary>
            Event raised when a buffer is returned to the pool.  This event is raised regardless of whether
            the returned buffer is stored or dropped.  In an ideal situation, the number of BufferReturned
            events exactly matches the number of BufferRented events.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.RetainableMemoryPoolEventSource.BufferTrimmed(System.Int32,System.Int32,System.Int32)">
            <summary>
            Event raised when we attempt to free a buffer due to inactivity or memory pressure (by no longer
            referencing it). It is possible (although not commmon) this buffer could be rented as we attempt
            to free it. A rent event before or after this event for the same ID, is a rare, but expected case.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.RetainableMemoryPoolEventSource.BufferTrimPoll(System.Int32,System.Int32)">
            <summary>
            Event raised when we check to trim buffers.
            </summary>
        </member>
        <member name="T:Spreads.Buffers.RetainedMemory`1">
            <summary>
            A borrowing of <see cref="T:Spreads.Buffers.RetainableMemory`1"/> that owns a reference from it.
            </summary>
            <remarks>
            Use this struct carefully: it must always be explicitly disposed, otherwise underlying MemoryManager implementation
            will never be returned to the pool and memory will leak or frequent GC will occur.
            <para/>
            RULE: Ownership of <see cref="T:Spreads.Buffers.RetainedMemory`1"/> is transferred in any method call without ref modifier (in modifier transfers ownership).
            Use <see cref="M:Spreads.Buffers.RetainedMemory`1.Clone"/> method or its <see cref="M:System.Span`1.Slice(System.Int32,System.Int32)"/>-like overloads to create a new borrowing of the underlying memory and to
            ensure that the underlying <see cref="T:Spreads.Buffers.RetainableMemory`1"/> is not returned to the pool.
            <para/>
            Access to this struct is not thread-safe, only one thread could call its methods at a time.
            </remarks>
        </member>
        <member name="M:Spreads.Buffers.RetainedMemory`1.#ctor(System.Memory{`0})">
            <summary>
            Create a new RetainedMemory from Memory and pins it.
            </summary>
            <param name="memory"></param>
        </member>
        <member name="P:Spreads.Buffers.RetainedMemory`1.Length">
            <summary>
            Gets the number of elements in the RetainedMemory.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.RetainedMemory`1.Clone">
            <summary>
            Create a copy and increment the reference counter.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.RetainedMemory`1.Clone(System.Int32)">
            <summary>
            Create a sliced copy and increment the reference counter.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.RetainedMemory`1.Clone(System.Int32,System.Int32)">
            <summary>
            Create a sliced copy and increment the reference counter.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.RetainedMemory`1.Dispose">
            <summary>
            Release a reference of the underlying OwnedBuffer.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.RetainedMemory`1.Forget">
            <summary>
            Stop tracking finalization.
            </summary>
        </member>
        <member name="M:Spreads.Buffers.RetainedMemoryExtensions.ToDirectBuffer(Spreads.Buffers.RetainedMemory{System.Byte})">
            <summary>
            A shortcut to <see cref="T:Spreads.Buffers.DirectBuffer"/> ctor that accepts <see cref="T:Spreads.Buffers.RetainedMemory`1"/>
            </summary>
        </member>
        <member name="T:Spreads.Buffers.VecStorage">
            <summary>
            VecStorage is a grouping of data as <see cref="F:Spreads.Buffers.VecStorage.Vec"/> and its source as <see cref="T:Spreads.Buffers.IRefCounted"/>, of which VecStorage borrows a counted reference.
            </summary>
            <remarks>
            This is a struct that must be disposed after it is no longer used.
            The intended usage is that this struct is a field of a class
            that implements <seealso cref="T:System.IDisposable"/> and calls <see cref="M:Spreads.Buffers.VecStorage.Dispose"/>
            method on this struct in its <see cref="M:System.IDisposable.Dispose"/>
            method. See <see cref="!:DataBlock"/> implementation as an example.
            </remarks>
        </member>
        <member name="F:Spreads.Buffers.VecStorage._memorySource">
            <summary>
            A source that owns Vec memory.
            </summary>
            <remarks>
            This is intended to be <see cref="T:Spreads.Buffers.RetainableMemory`1"/>, but we do not have T here and only care about ref counting.
            </remarks>
        </member>
        <member name="M:Spreads.Buffers.VecStorage.Slice(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Returns new VectorStorage instance with the same memory source but (optionally) different memory start and length.
            Increments underlying memory reference count.
            </summary>
        </member>
        <member name="P:Spreads.Buffers.VecStorage.IsExternallyOwned">
            <summary>
            True if this VectorStorage does not own a RefCount of the underlying memory source.
            </summary>
        </member>
        <member name="T:Spreads.Collections.Concurrent.BoundedConcurrentBag`1">
            <summary>
            Object pool based on ConcurrentBag
            </summary>
        </member>
        <member name="T:Spreads.Collections.Concurrent.BoundedConcurrentQueue`1">
             <summary>
            
             </summary>
        </member>
        <member name="T:Spreads.Collections.Concurrent.IStorageIndexed">
            <summary>
            An interface for an object that could be retrieved by an int index.
            <see cref="P:Spreads.Collections.Concurrent.IStorageIndexed.StorageIndex"/> is set by <see cref="T:Spreads.Collections.Concurrent.IndexedLockedWeakDictionary`2"/>
            on addition and then could be used for lookup using <see cref="M:Spreads.Collections.Concurrent.IndexedLockedWeakDictionary`2.TryGetByIndex(System.Int32,`1@)"/> method.
            </summary>
        </member>
        <member name="T:Spreads.Collections.Concurrent.IndexedLookup`2">
            <summary>
            An example and potentially base class for values in <see cref="T:Spreads.Collections.Concurrent.IndexedLockedWeakDictionary`2"/>.
            </summary>
        </member>
        <member name="T:Spreads.Collections.Concurrent.IndexedLockedWeakDictionary`2">
            <summary>
            Long-term storage where added items could be retrieved by ushort index.
            Pessimized write operations in favor of fast reads. Scenario is for
            a lot of objects stored as weak references and cleaned when no used.
            </summary>
        </member>
        <member name="T:Spreads.Collections.Concurrent.LockedDictionary`2">
            <summary>
            Useful together with a thread pool when we repeatedly do some work over a fixed set of objects.
            TryPop will remove an item for processing but an item with the same key could be added back.
            If an item already exists it is just overwritten and the size of the dictionary remains constant.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Spreads.Collections.Concurrent.LockedDictionary`2.Set(`0,`1)">
            <summary>
            Sets a value regardless if the key is already present or not.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Concurrent.LockedDictionary`2.TryPop(System.Collections.Generic.KeyValuePair{`0,`1}@)">
            <summary>
            Removes the first found value from the dictionary and returns it.
            </summary>
        </member>
        <member name="T:Spreads.Collections.Concurrent.LockedObjectPool`1">
            <summary>
            Thread-safe simple object pool.
            This pool is intended for storage and should not drop objects if there is space available.
            Good for native resources as opposed to <see cref="T:Spreads.Collections.Concurrent.ObjectPool`1"/>, which is only good for reducing managed objects allocations.
            </summary>
        </member>
        <member name="T:Spreads.Collections.Concurrent.LockedWeakDictionary`1">
            <summary>
            A dictionary that stores <see cref="T:System.Runtime.InteropServices.GCHandle"/> with <see cref="F:System.Runtime.InteropServices.GCHandleType.Weak"/> option.
            Used for caches when reads are significantly more frequent than writes and multi-threaded access
            is usually not contended. For other cases <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> may be better.
            </summary>
            <remarks>
            Another use case is for frequent enumeration of small concurrent dictionaries while <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            doesn't have struct enumerator. Currently we have to Enter/Exit lock manually and enumerate <see cref="P:Spreads.Collections.Concurrent.LockedWeakDictionary`1.InnerDictionary"/> manually,
            possible with try/catch if during enumeration we are doing some job that could throw.
            </remarks>
        </member>
        <member name="T:Spreads.Collections.Concurrent.ObjectPool`1">
             <summary>
             Generic implementation of object pooling pattern with predefined pool size limit. The main
             purpose is that limited number of frequently used objects can be kept in the pool for
             further recycling.
            
             Notes:
             1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
                is no space in the pool, extra returned objects will be dropped.
            
             2) it is implied that if object was obtained from a pool, the caller will return it back in
                a relatively short time. Keeping checked out objects for long durations is ok, but
                reduces usefulness of pooling. Just new up your own.
            
             Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice.
             Rationale:
                If there is no intent for reusing the object, do not use pool - just use "new".
             </summary>
        </member>
        <member name="M:Spreads.Collections.Concurrent.ObjectPool`1.Allocate">
            <summary>
            Produces an instance.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically
            reducing how far we will typically search.
            </remarks>
        </member>
        <member name="M:Spreads.Collections.Concurrent.ObjectPool`1.Free(`0)">
            <summary>
            Returns objects to the pool.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically
            reducing how far we will typically search in Allocate.
            </remarks>
        </member>
        <member name="M:Spreads.Collections.Concurrent.ObjectPool`1.ForgetTrackedObject(`0,`0)">
             <summary>
             Removes an object from leak tracking.
            
             This is called when an object is returned to the pool.  It may also be explicitly
             called if an object allocated from the pool is intentionally not being returned
             to the pool.  This can be of use with pooled arrays if the consumer wants to
             return a larger array to the pool than was originally allocated.
             </summary>
        </member>
        <member name="T:Spreads.Collections.Concurrent.PriorityChannel`1">
            <summary>
            Single-producer single-consumer queue with a priority channel that allows priority items jump ahead of normal ones.
            All items with the same priority are FIFO.
            </summary>
        </member>
        <member name="T:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1">
            <summary>
            Provides a producer/consumer queue safe to be used by only one producer and one consumer concurrently.
            </summary>
            <typeparam name="T">Specifies the type of data contained in the queue.</typeparam>
        </member>
        <member name="F:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.InitialSegmentSize">
            <summary>The initial size to use for segments (in number of elements).</summary>
        </member>
        <member name="F:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.MaxSegmentSize">
            <summary>The maximum size to use for segments (in number of elements).</summary>
        </member>
        <member name="F:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1._head">
            <summary>The head of the linked list of segments.</summary>
        </member>
        <member name="F:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1._tail">
            <summary>The tail of the linked list of segments.</summary>
        </member>
        <member name="M:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.#ctor">
            <summary>Initializes the queue.</summary>
        </member>
        <member name="M:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.Enqueue(`0)">
            <summary>Enqueues an item into the queue.</summary>
            <param name="item">The item to enqueue.</param>
        </member>
        <member name="M:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.EnqueueSlow(`0,Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue{`0}.Segment@)">
            <summary>Enqueues an item into the queue.</summary>
            <param name="item">The item to enqueue.</param>
            <param name="segment">The segment in which to first attempt to store the item.</param>
        </member>
        <member name="M:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.TryDequeue(`0@)">
            <summary>Attempts to dequeue an item from the queue.</summary>
            <param name="result">The dequeued item.</param>
            <returns>true if an item could be dequeued; otherwise, false.</returns>
        </member>
        <member name="M:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.TryDequeueSlow(Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue{`0}.Segment@,`0[]@,`0@)">
            <summary>Attempts to dequeue an item from the queue.</summary>
            <param name="array">The array from which the item was dequeued.</param>
            <param name="segment">The segment from which the item was dequeued.</param>
            <param name="result">The dequeued item.</param>
            <returns>true if an item could be dequeued; otherwise, false.</returns>
        </member>
        <member name="P:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.IsEmpty">
            <summary>Gets whether the collection is currently empty.</summary>
        </member>
        <member name="M:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.GetEnumerator">
            <summary>Gets an enumerable for the collection.</summary>
            <remarks>This method is not safe to use concurrently with any other members that may mutate the collection.</remarks>
        </member>
        <member name="P:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.Count">
            <summary>Gets the number of items in the collection.</summary>
            <remarks>This method is not safe to use concurrently with any other members that may mutate the collection.</remarks>
        </member>
        <member name="T:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.Segment">
            <summary>A segment in the queue containing one or more items.</summary>
        </member>
        <member name="F:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.Segment._next">
            <summary>The next segment in the linked list of segments.</summary>
        </member>
        <member name="F:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.Segment._array">
            <summary>The data stored in this segment.</summary>
        </member>
        <member name="F:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.Segment._state">
            <summary>Details about the segment.</summary>
        </member>
        <member name="M:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.Segment.#ctor(System.Int32)">
            <summary>Initializes the segment.</summary>
            <param name="size">The size to use for this segment.</param>
        </member>
        <member name="T:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SegmentState">
            <summary>Stores information about a segment.</summary>
        </member>
        <member name="F:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SegmentState._pad0">
            <summary>Padding to reduce false sharing between the segment's array and _first.</summary>
        </member>
        <member name="F:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SegmentState._first">
            <summary>The index of the current head in the segment.</summary>
        </member>
        <member name="F:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SegmentState._lastCopy">
            <summary>A copy of the current tail index.</summary>
        </member>
        <member name="F:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SegmentState._pad1">
            <summary>Padding to reduce false sharing between the first and last.</summary>
        </member>
        <member name="F:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SegmentState._firstCopy">
            <summary>A copy of the current head index.</summary>
        </member>
        <member name="F:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SegmentState._last">
            <summary>The index of the current tail in the segment.</summary>
        </member>
        <member name="F:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SegmentState._pad2">
            <summary>Padding to reduce false sharing with the last and what's after the segment.</summary>
        </member>
        <member name="T:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SingleProducerSingleConsumerQueue_DebugView">
            <summary>Debugger type proxy for a SingleProducerSingleConsumerQueue of T.</summary>
        </member>
        <member name="F:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SingleProducerSingleConsumerQueue_DebugView._queue">
            <summary>The queue being visualized.</summary>
        </member>
        <member name="M:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SingleProducerSingleConsumerQueue_DebugView.#ctor(Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue{`0})">
            <summary>Initializes the debug view.</summary>
            <param name="queue">The queue being debugged.</param>
        </member>
        <member name="P:Spreads.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SingleProducerSingleConsumerQueue_DebugView.Items">
            <summary>Gets the contents of the list.</summary>
        </member>
        <member name="T:Spreads.Collections.Concurrent.PaddingHelpers">
            <summary>A placeholder class for common padding constants and eventually routines.</summary>
        </member>
        <member name="F:Spreads.Collections.Concurrent.PaddingHelpers.CACHE_LINE_SIZE">
            <summary>A size greater than or equal to the size of the most common CPU cache lines.</summary>
        </member>
        <member name="T:Spreads.Collections.Concurrent.PaddingFor32">
            <summary>Padding structure used to minimize false sharing in SingleProducerSingleConsumerQueue{T}.</summary>
        </member>
        <member name="T:Spreads.Collections.Generic.DictionarySlim`2">
             <summary>
             A lightweight Dictionary with three principal differences compared to <see cref="T:System.Collections.Generic.Dictionary`2"/>
            
             1) It is possible to do "get or add" in a single lookup using <see cref="M:Spreads.Collections.Generic.DictionarySlim`2.GetOrAddValueRef(`0)"/>. For
             values that are value types, this also saves a copy of the value.
             2) It assumes it is cheap to equate values.
             3) It assumes the keys implement <see cref="T:System.IEquatable`1"/> or else Equals() and they are cheap and sufficient.
             </summary>
             <remarks>
             1) This avoids having to do separate lookups (<see cref="M:System.Collections.Generic.Dictionary`2.TryGetValue(`0,`1@)"/>
             followed by <see cref="M:System.Collections.Generic.Dictionary`2.Add(`0,`1)"/>.
             There is not currently an API exposed to get a value by ref without adding if the key is not present.
             2) This means it can save space by not storing hash codes.
             3) This means it can avoid storing a comparer, and avoid the likely virtual call to a comparer.
             </remarks>
        </member>
        <member name="M:Spreads.Collections.Generic.DictionarySlim`2.#ctor">
            <summary>
            Construct with default capacity.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.DictionarySlim`2.#ctor(System.Int32)">
            <summary>
            Construct with at least the specified capacity for
            entries before resizing must occur.
            </summary>
            <param name="capacity">Requested minimum capacity</param>
        </member>
        <member name="P:Spreads.Collections.Generic.DictionarySlim`2.Count">
            <summary>
            Count of entries in the dictionary.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.DictionarySlim`2.Clear">
            <summary>
            Clears the dictionary. Note that this invalidates any active enumerators.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.DictionarySlim`2.ContainsKey(`0)">
            <summary>
            Looks for the specified key in the dictionary.
            </summary>
            <param name="key">Key to look for</param>
            <returns>true if the key is present, otherwise false</returns>
        </member>
        <member name="M:Spreads.Collections.Generic.DictionarySlim`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value if present for the specified key.
            </summary>
            <param name="key">Key to look for</param>
            <param name="value">Value found, otherwise default(TValue)</param>
            <returns>true if the key is present, otherwise false</returns>
        </member>
        <member name="M:Spreads.Collections.Generic.DictionarySlim`2.DangerousTryGetValue(`0,`1@)">
            <summary>
            Assumes no concurrent updates are possible.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.DictionarySlim`2.Remove(`0)">
            <summary>
            Removes the entry if present with the specified key.
            </summary>
            <param name="key">Key to look for</param>
            <returns>true if the key is present, false if it is not</returns>
        </member>
        <member name="M:Spreads.Collections.Generic.DictionarySlim`2.GetOrAddValueRef(`0)">
            <summary>
            Gets the value for the specified key, or, if the key is not present,
            adds an entry and returns the value by ref. This makes it possible to
            add or update a value in a single look up operation.
            </summary>
            <param name="key">Key to look for</param>
            <returns>Reference to the new or existing value</returns>
        </member>
        <member name="M:Spreads.Collections.Generic.DictionarySlim`2.GetEnumerator">
            <summary>
            Gets an enumerator over the dictionary
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.DictionarySlim`2.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{TKey,TValue}}#GetEnumerator">
            <summary>
            Gets an enumerator over the dictionary
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.DictionarySlim`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator over the dictionary
            </summary>
        </member>
        <member name="T:Spreads.Collections.Generic.DictionarySlim`2.Enumerator">
            <summary>
            Enumerator
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.DictionarySlim`2.Enumerator.MoveNext">
            <summary>
            Move to next
            </summary>
        </member>
        <member name="P:Spreads.Collections.Generic.DictionarySlim`2.Enumerator.Current">
            <summary>
            Get current value
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.DictionarySlim`2.Enumerator.Dispose">
            <summary>
            Dispose the enumerator
            </summary>
        </member>
        <member name="T:Spreads.Collections.Generic.InsertionBehavior">
            <summary>
            Used internally to control behavior of insertion into a <see cref="T:Spreads.Collections.Generic.FastDictionary`2"/>.
            </summary>
        </member>
        <member name="F:Spreads.Collections.Generic.InsertionBehavior.None">
            <summary>
            The default insertion behavior.
            </summary>
        </member>
        <member name="F:Spreads.Collections.Generic.InsertionBehavior.OverwriteExisting">
            <summary>
            Specifies that an existing entry with the same key should be overwritten if encountered.
            </summary>
        </member>
        <member name="F:Spreads.Collections.Generic.InsertionBehavior.ThrowOnExisting">
            <summary>
            Specifies that if an existing entry with the same key is encountered, an exception should be thrown.
            </summary>
        </member>
        <member name="T:Spreads.Collections.Generic.FastDictionary`2">
            <summary>
            A modified <see cref="T:System.Collections.Generic.Dictionary`2"/> that uses a fast <see cref="T:Spreads.KeyEqualityComparer`1"/> comparer.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:Spreads.Collections.Generic.FixedMaxHeap`1">
            <summary>
            Very simple heap data structure, of fixed size.
            </summary>
            <typeparam name="TElement"></typeparam>
        </member>
        <member name="T:Spreads.Collections.Generic.RefList`1">
            <summary>
            A <see cref="T:System.Collections.Generic.List`1"/> with an indexer that returns a reference to an item.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Spreads.Collections.Generic.SortedDeque`1">
            <summary>
            SortedDeque for KeyValuePairs.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`1.#ctor(System.Int32,Spreads.KeyComparer{`0})">
            <summary>
            Create a new instance of SortedDeque with the given comparer.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`1.#ctor(System.Int32)">
            <summary>
            Create a new instance of SortedDeque with a default comparer.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`1.#ctor">
            <summary>
            Create a new instance of SortedDeque with a default comparer.
            </summary>
        </member>
        <member name="P:Spreads.Collections.Generic.SortedDeque`1.Count">
            <summary>
            Number of elements in this SortedDeque.
            </summary>
        </member>
        <member name="P:Spreads.Collections.Generic.SortedDeque`1.Capacity">
            <summary>
            Current capacity.
            </summary>
        </member>
        <member name="P:Spreads.Collections.Generic.SortedDeque`1.First">
            <summary>
            Get the first element.
            </summary>
        </member>
        <member name="P:Spreads.Collections.Generic.SortedDeque`1.Last">
            <summary>
            Get the last element.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`1.InsertAtOffset(System.Int32,`0)">
            Offset is the place where a new element must be if we always shift
            existing elements to the right. Here, we could shift existing elements
            to the left if doing so is faster, so the new element could end up
            at offset-1 place.
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`1.Add(`0)">
            <summary>
            Add a new element.
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`1.TryAdd(`0)">
            <summary>
            Try add a new element.
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`1.Set(`0)">
            <summary>
            Add or replace an element.
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`1.Clear">
            <summary>
            Remove all elements.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`1.RemoveFirst">
            <summary>
            Remove and return the first element.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`1.RemoveLast">
            <summary>
            Remove and return the last element.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`1.Remove(`0)">
            <summary>
            Remove and return the element.
            </summary>
            <returns>
            Returns an element from this SortedDeque that matches to the given element according to the comparer.
            </returns>
            <remarks>
            This method returns an element instead of void because comparer could take only a part of the given element, and the returned value could be different.
            </remarks>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`1.RemoveAt(System.Int32)">
            <summary>
            Remove an element at index.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="P:Spreads.Collections.Generic.SortedDeque`1.Item(System.Int32)">
            <summary>
            Get an element at the index.
            </summary>
        </member>
        <member name="T:Spreads.Collections.Generic.SortedDeque`1.SortedDequeEnumerator">
            <summary>
            SortedDeque enumerator.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`1.SortedDequeEnumerator.#ctor(Spreads.Collections.Generic.SortedDeque{`0})">
            <summary>
            Create a new SortedDequeEnumerator instance.
            </summary>
        </member>
        <member name="P:Spreads.Collections.Generic.SortedDeque`1.SortedDequeEnumerator.Current">
            <inheritdoc />
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`1.SortedDequeEnumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`1.SortedDequeEnumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`1.SortedDequeEnumerator.Reset">
            <inheritdoc />
        </member>
        <member name="T:Spreads.Collections.Generic.SortedDeque`2">
            <summary>
            SortedDeque for KeyValuePairs.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`2.#ctor(System.Int32,Spreads.KVPComparer{`0,`1})">
            <summary>
            Create a new instance of SortedDeque with the given comparer.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`2.#ctor(System.Int32)">
            <summary>
            Create a new instance of SortedDeque with a default comparer.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`2.#ctor">
            <summary>
            Create a new instance of SortedDeque with a default comparer.
            </summary>
        </member>
        <member name="P:Spreads.Collections.Generic.SortedDeque`2.Count">
            <summary>
            Number of elements in this SortedDeque.
            </summary>
        </member>
        <member name="P:Spreads.Collections.Generic.SortedDeque`2.Capacity">
            <summary>
            Current capacity.
            </summary>
        </member>
        <member name="P:Spreads.Collections.Generic.SortedDeque`2.First">
            <summary>
            Get the first element.
            </summary>
        </member>
        <member name="P:Spreads.Collections.Generic.SortedDeque`2.Last">
            <summary>
            Get the last element.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`2.InsertAtOffset(System.Int32,System.Collections.Generic.KeyValuePair{`0,`1})">
            Offset is the place where a new element must be if we always shift
            existing elements to the right. Here, we could shift existing elements
            to the left if doing so is faster, so the new element could end up
            at offset-1 place.
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Add a new element.
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`2.TryAdd(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Try add a new element.
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`2.Set(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Add or replace an element.
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`2.Clear">
            <summary>
            Remove all elements.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`2.RemoveFirst">
            <summary>
            Remove and return the first element.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`2.RemoveLast">
            <summary>
            Remove and return the last element.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Remove and return the element.
            </summary>
            <returns>
            Returns an element from this SortedDeque that matches to the given element according to the comparer.
            </returns>
            <remarks>
            This method returns an element instead of void because comparer could take only a part of the given element, and the returned value could be different.
            </remarks>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`2.RemoveAt(System.Int32)">
            <summary>
            Remove an element at index.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="P:Spreads.Collections.Generic.SortedDeque`2.Item(System.Int32)">
            <summary>
            Get an element at the index.
            </summary>
        </member>
        <member name="T:Spreads.Collections.Generic.SortedDeque`2.SortedDequeEnumerator">
            <summary>
            SortedDeque enumerator.
            </summary>
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`2.SortedDequeEnumerator.#ctor(Spreads.Collections.Generic.SortedDeque{`0,`1})">
            <summary>
            Create a new SortedDequeEnumerator instance.
            </summary>
        </member>
        <member name="P:Spreads.Collections.Generic.SortedDeque`2.SortedDequeEnumerator.Current">
            <inheritdoc />
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`2.SortedDequeEnumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`2.SortedDequeEnumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Spreads.Collections.Generic.SortedDeque`2.SortedDequeEnumerator.Reset">
            <inheritdoc />
        </member>
        <member name="P:Spreads.Collections.IVector`1.Length">
            <summary>
            Get the total number of items in IVector.
            </summary>
        </member>
        <member name="M:Spreads.Collections.IVector`1.GetItem(System.Int32)">
            <summary>
            Returns an item at the specified index.
            </summary>
        </member>
        <member name="M:Spreads.Collections.IVector`1.DangerousGetItem(System.Int32)">
            <summary>
            Returns an item at the specified index without bound checks.
            </summary>
        </member>
        <member name="P:Spreads.Collections.IVector.Length">
            <summary>
            Get the total number of elements in Vec.
            </summary>
        </member>
        <member name="M:Spreads.Collections.IVector.Get``1(System.Int32)">
            <summary>
            Returns the element at the specified index.
            </summary>
        </member>
        <member name="M:Spreads.Collections.IVector.DangerousGet``1(System.Int32)">
            <summary>
            Returns the element at the specified index without bound and type checks.
            </summary>
        </member>
        <member name="T:Spreads.Collections.Offset">
            <summary>
            A marker struct for <see cref="T:System.Int64"/> with explicit conversions to it.
            </summary>
            <remarks>
            It is similar to type aliases in F#.
            Useful for preventing wrong usage of some index as an Offset or for method overloading.
            </remarks>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.BinarySearch``1(Spreads.Native.Vec{``0}@,System.Int32,System.Int32,``0,Spreads.KeyComparer{``0})">
            <summary>
            Performs standard binary search and returns index of the value or its negative binary complement.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.DangerousBinarySearch``1(Spreads.Native.Vec{``0}@,System.Int32,System.Int32,``0,Spreads.KeyComparer{``0})">
            <summary>
            Performs <see cref="M:Spreads.Collections.VectorExtensions.BinarySearch``1(Spreads.Native.Vec{``0}@,System.Int32,System.Int32,``0,Spreads.KeyComparer{``0})"/> without bound checks.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.BinarySearch``1(``0[],``0,Spreads.KeyComparer{``0})">
            <summary>
            Performs standard binary search and returns index of the value or its negative binary complement.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.BinarySearch``1(``0[],System.Int32,System.Int32,``0,Spreads.KeyComparer{``0})">
            <summary>
            Performs standard binary search and returns index of the value or its negative binary complement.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.DangerousBinarySearch``1(``0[],System.Int32,System.Int32,``0,Spreads.KeyComparer{``0})">
            <summary>
            <see cref="M:Spreads.Collections.VectorExtensions.InterpolationSearch``1(``0[],System.Int32,System.Int32,``0,Spreads.KeyComparer{``0})"/> without bound checks.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.BinarySearch``1(Spreads.Collections.ArrayVector{``0},``0,Spreads.KeyComparer{``0})">
            <summary>
            Performs standard binary search and returns index of the value or its negative binary complement.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.BinarySearch``1(Spreads.Collections.ArrayVector{``0},System.Int32,System.Int32,``0,Spreads.KeyComparer{``0})">
            <summary>
            Performs standard binary search and returns index of the value or its negative binary complement.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.DangerousBinarySearch``1(Spreads.Collections.ArrayVector{``0},System.Int32,System.Int32,``0,Spreads.KeyComparer{``0})">
            <summary>
            <see cref="M:Spreads.Collections.VectorExtensions.BinarySearch``1(Spreads.Collections.ArrayVector{``0},System.Int32,System.Int32,``0,Spreads.KeyComparer{``0})"/> without bound checks.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.BinaryLookup``1(Spreads.Native.Vec{``0}@,System.Int32,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            Find value using binary search according to the lookup direction.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.DangerousBinaryLookup``1(Spreads.Native.Vec{``0}@,System.Int32,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            <see cref="M:Spreads.Collections.VectorExtensions.BinaryLookup``1(Spreads.Native.Vec{``0}@,System.Int32,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})"/> without bound checks.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.BinaryLookup``1(``0[],``0@,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            Find value using binary search according to the lookup direction.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.BinaryLookup``1(``0[],System.Int32,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            Find value using binary search according to the lookup direction.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.DangerousBinaryLookup``1(``0[],System.Int32,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            <see cref="M:Spreads.Collections.VectorExtensions.BinaryLookup``1(``0[],System.Int32,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})"/> without bound checks.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.BinaryLookup``1(Spreads.Collections.ArrayVector{``0},``0@,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            Find value using binary search according to the lookup direction.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.BinaryLookup``1(Spreads.Collections.ArrayVector{``0},System.Int32,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            Find value using binary search according to the lookup direction.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.DangerousBinaryLookup``1(Spreads.Collections.ArrayVector{``0},System.Int32,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            <see cref="M:Spreads.Collections.VectorExtensions.BinaryLookup``1(Spreads.Collections.ArrayVector{``0},System.Int32,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})"/> without bound checks.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.InterpolationSearch``1(Spreads.Native.Vec{``0}@,System.Int32,System.Int32,``0,Spreads.KeyComparer{``0})">
            <summary>
            Performs interpolation search and returns index of the value or its negative binary complement.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.DangerousInterpolationSearch``1(Spreads.Native.Vec{``0}@,System.Int32,System.Int32,``0,Spreads.KeyComparer{``0})">
            <summary>
            <see cref="M:Spreads.Collections.VectorExtensions.InterpolationSearch``1(Spreads.Native.Vec{``0}@,System.Int32,System.Int32,``0,Spreads.KeyComparer{``0})"/> without bound checks.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.InterpolationSearch``1(``0[],``0,Spreads.KeyComparer{``0})">
            <summary>
            Performs interpolation search and returns index of the value or its negative binary complement.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.InterpolationSearch``1(``0[],System.Int32,System.Int32,``0,Spreads.KeyComparer{``0})">
            <summary>
            Performs interpolation search and returns index of the value or its negative binary complement.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.DangerousInterpolationSearch``1(``0[],System.Int32,System.Int32,``0,Spreads.KeyComparer{``0})">
            <summary>
            <see cref="M:Spreads.Collections.VectorExtensions.InterpolationSearch``1(``0[],System.Int32,System.Int32,``0,Spreads.KeyComparer{``0})"/> without bound checks.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.InterpolationSearch``1(Spreads.Collections.ArrayVector{``0},``0,Spreads.KeyComparer{``0})">
            <summary>
            Performs interpolation search and returns index of the value or its negative binary complement.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.InterpolationSearch``1(Spreads.Collections.ArrayVector{``0},System.Int32,System.Int32,``0,Spreads.KeyComparer{``0})">
            <summary>
            Performs interpolation search and returns index of the value or its negative binary complement.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.DangerousInterpolationSearch``1(Spreads.Collections.ArrayVector{``0},System.Int32,System.Int32,``0,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            <see cref="M:Spreads.Collections.VectorExtensions.InterpolationSearch``1(Spreads.Collections.ArrayVector{``0},System.Int32,System.Int32,``0,Spreads.KeyComparer{``0})"/> without bound checks.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.InterpolationLookup``1(Spreads.Native.Vec{``0}@,System.Int32,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            Find value using interpolation search according to the lookup direction.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.DangerousInterpolationLookup``1(Spreads.Native.Vec{``0}@,System.Int32,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            <see cref="M:Spreads.Collections.VectorExtensions.InterpolationLookup``1(Spreads.Native.Vec{``0}@,System.Int32,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})"/> without bound checks.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.InterpolationLookup``1(``0[],``0@,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            Find value using binary search according to the lookup direction.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.InterpolationLookup``1(``0[],System.Int32,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            Find value using binary search according to the lookup direction.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.DangerousInterpolationLookup``1(``0[],System.Int32,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            <see cref="M:Spreads.Collections.VectorExtensions.InterpolationLookup``1(``0[],System.Int32,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})"/> without bound checks.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.InterpolationLookup``1(Spreads.Collections.ArrayVector{``0},``0@,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            Find value using interpolation search according to the lookup direction.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.InterpolationLookup``1(Spreads.Collections.ArrayVector{``0},System.Int32,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            Find value using interpolation search according to the lookup direction.
            </summary>
        </member>
        <member name="M:Spreads.Collections.VectorExtensions.DangerousInterpolationLookup``1(Spreads.Collections.ArrayVector{``0},System.Int32,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})">
            <summary>
            <see cref="M:Spreads.Collections.VectorExtensions.InterpolationLookup``1(Spreads.Collections.ArrayVector{``0},System.Int32,System.Int32,``0@,Spreads.Lookup,Spreads.KeyComparer{``0})"/> without bound checks.
            </summary>
        </member>
        <member name="F:Spreads.CursorState.None">
            <summary>
            A cursor is not initialized or is disposed. Some (re)initialization work may be needed before moving.
            </summary>
        </member>
        <member name="F:Spreads.CursorState.Initialized">
            <summary>
            A cursor is initialized via GetCursor() call of ISeries and is ready to move.
            The cursor is "nowhere" with this state (before the first element for <see cref="!:ICursor&lt;TKey,TValue&gt;.MoveNext()"/>, after the last element for <see cref="!:ICursor&lt;TKey,TValue&gt;.MovePrevious()"/>).
            </summary>
        </member>
        <member name="F:Spreads.CursorState.Moving">
            <summary>
            A cursor has started moving and is at a valid position.
            A false move from this state must restore the cursor to its position before the move.
            </summary>
        </member>
        <member name="T:Spreads.DataTypes.ErrorCode">
            <summary>
            A known type to represent an error code as a wrapper over Int64.
            </summary>
        </member>
        <member name="T:Spreads.DataTypes.Id">
            <summary>
            A marker structure to have type safety for integer identity id.
            </summary>
            <remarks>
            It is similar to type aliases in F#.
            Useful for preventing wrong usage of some index as an Id or for method overloading.
            </remarks>
        </member>
        <member name="F:Spreads.DataTypes.Id.None">
            <summary>
            Invalid/zero/none identity id.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Id.Equals(Spreads.DataTypes.Id)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Id.GetTypeCode">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Id.ToBoolean(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Id.ToByte(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Id.ToChar(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Id.ToDateTime(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Id.ToDecimal(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Id.ToDouble(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Id.ToInt16(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Id.ToInt32(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Id.ToInt64(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Id.ToSByte(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Id.ToSingle(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Id.ToString(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Id.ToType(System.Type,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Id.ToUInt16(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Id.ToUInt32(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Id.ToUInt64(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Id.op_Explicit(System.Int32)~Spreads.DataTypes.Id">
            <summary>
            Explicit cast from int to IdentityId.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Id.op_Explicit(Spreads.DataTypes.Id)~System.Int32">
            <summary>
            Explicit cast from IdentityId to int.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Id.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Id.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Id.ToString">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Id.op_Equality(Spreads.DataTypes.Id,Spreads.DataTypes.Id)">
            <summary>
            Equals operator.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Id.op_Inequality(Spreads.DataTypes.Id,Spreads.DataTypes.Id)">
            <summary>
            Not equals operator.
            </summary>
        </member>
        <member name="T:Spreads.DataTypes.Json">
            <summary>
            Wrapper for UTF8 JSON string.
            </summary>
        </member>
        <member name="T:Spreads.DataTypes.MarketDepth">
            <summary>
            A structure to represent "Small" best bids and asks.
            Often best bids and asks have very small volume, which could create noise.
            "Small" price is a WAP price we will pay/receive to buy/sell "Small" quantity.
            The values are constructed from a limit order book snapshots to simplify modeling of historical
            market depth, reduce memory and increase speed.
            The notion of "Small" depends on the context.
            Offset is the number of minimum price steps from absolute best bid/ask.
            Allows to recover those absolute best bid/ask levels with known price step or estimate market impact.
            Offset equalt to zero indicates that this is the best bid/ask.
            </summary>
        </member>
        <member name="T:Spreads.DataTypes.MarketDepth2">
            <summary>
            A structure to represent "Small" and "Large" best bids and asks.
            Often best bids and asks have very small volume, which could create noise.
            "Small/Large" price is a WAP price we will pay/receive to buy/sell "Small/Large" quantity.
            The values are constructed from a limit order book snapshots to simplify modeling of historical
            market depth, reduce memory and increase speed.
            The notion of "Small/Large" depends on the context.
            Offset is the number of minimum price steps from absolute best bid/ask.
            Allows to recover those absolute best bid/ask levels with known price step or estimate market impact.
            </summary>
        </member>
        <member name="T:Spreads.DataTypes.OrderBagDecimal">
            <summary>
            Simple and lazy DTO for OrderBook.
            </summary>
        </member>
        <member name="T:Spreads.DataTypes.OrderBookQuotes">
            <summary>
            Data transfer object to store simple order book info. It has no additional functionality other than data storage.
            Sell orders has negative volume. Quotes are sorted in ascending order.
            </summary>
        </member>
        <member name="T:Spreads.DataTypes.IQuote`1">
            <summary>
            IQuote interface.
            </summary>
        </member>
        <member name="P:Spreads.DataTypes.IQuote`1.Price">
            <summary>
            Price.
            </summary>
        </member>
        <member name="P:Spreads.DataTypes.IQuote`1.Volume">
            <summary>
            Volume.
            </summary>
        </member>
        <member name="T:Spreads.DataTypes.QuoteDecimal">
             <summary>
             A blittable structure to store quotes.
             </summary>
             <remarks>
             Price cannot be floating point, but decimal is slow and fat 16 bytes, plus such precision is not needed.
             Volume is in price units, 4B lots is a lot.
             Tag is often needed to store additional data.
            
             This struct could represent a single or aggregate order at level in an order book, tag allows to lookup additoinal
             info without polluting and slowing down order book. Tag is application-specific. When not used, it has zero cost
             when data is serialized and compressed. When is memory, it guarantees alignment of Price field that could make
             processing somewhat faster.
             </remarks>
        </member>
        <member name="P:Spreads.DataTypes.QuoteDecimal.Price">
            <inheritdoc />
        </member>
        <member name="P:Spreads.DataTypes.QuoteDecimal.Volume">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.QuoteDecimal.#ctor(Spreads.DataTypes.SmallDecimal,Spreads.DataTypes.SmallDecimal)">
            <summary>
            Quote constructor.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.QuoteDecimal.Equals(Spreads.DataTypes.QuoteDecimal)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.QuoteDecimal.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.QuoteDecimal.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:Spreads.DataTypes.Quote">
             <summary>
             A blittable structure to store quotes.
             </summary>
             <remarks>
             Price cannot be floating point, but decimal is slow and fat 16 bytes, plus such precision is not needed.
             Volume is in price units, 4B lots is a lot.
             Tag is often needed to store additional data.
            
             This struct could represent a single or aggregate order at level in an order book, tag allows to lookup additoinal
             info without polluting and slowing down order book. Tag is application-specific. When not used, it has zero cost
             when data is serialized and compressed. When is memory, it guarantees alignment of Price field that could make
             processing somewhat faster.
             </remarks>
        </member>
        <member name="P:Spreads.DataTypes.Quote.Price">
            <inheritdoc />
        </member>
        <member name="P:Spreads.DataTypes.Quote.Volume">
            <inheritdoc />
        </member>
        <member name="P:Spreads.DataTypes.Quote.Tag">
            <summary>
            An Int32 value that serves as padding or could be used to store any custom data.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Quote.#ctor(Spreads.DataTypes.SmallDecimal,System.Int32)">
            <summary>
            Quote constructor.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Quote.Equals(Spreads.DataTypes.Quote)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Quote.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Quote.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Quote.GetDelta(Spreads.DataTypes.Quote)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Quote.AddDelta(Spreads.DataTypes.Quote)">
            <inheritdoc />
        </member>
        <member name="T:Spreads.DataTypes.ITick">
            <summary>
            ITick interface.
            </summary>
        </member>
        <member name="P:Spreads.DataTypes.ITick.DateTimeUtc">
             <summary>
            
             </summary>
        </member>
        <member name="T:Spreads.DataTypes.Tick">
            <summary>
            A blittable structure to store ticks.
            </summary>
        </member>
        <member name="P:Spreads.DataTypes.Tick.DateTimeUtc">
            <summary>
            UTC DateTime
            </summary>
        </member>
        <member name="P:Spreads.DataTypes.Tick.Price">
            <inheritdoc />
        </member>
        <member name="P:Spreads.DataTypes.Tick.Volume">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Tick.#ctor(System.DateTime,Spreads.DataTypes.SmallDecimal,System.Int32)">
            <summary>
            Tick constructor.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Tick.Equals(Spreads.DataTypes.Tick)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Tick.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Tick.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Tick.GetDelta(Spreads.DataTypes.Tick)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Tick.AddDelta(Spreads.DataTypes.Tick)">
            <inheritdoc />
        </member>
        <member name="T:Spreads.DataTypes.TickDecimal">
            <summary>
            A blittable structure to store ticks.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.TickDecimal.Equals(Spreads.DataTypes.TickDecimal)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.TickDecimal.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.TickDecimal.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.TickDecimal.GetDelta(Spreads.DataTypes.TickDecimal)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.TickDecimal.AddDelta(Spreads.DataTypes.TickDecimal)">
            <inheritdoc />
        </member>
        <member name="T:Spreads.DataTypes.TradeSide">
            <summary>
            Trade side enum: Buy, Sell or None (default)
            </summary>
        </member>
        <member name="F:Spreads.DataTypes.TradeSide.None">
            <summary>
            By default, this should be always zero, so if there is an error and we forget to specify the Side, we must fail fast.
            </summary>
        </member>
        <member name="F:Spreads.DataTypes.TradeSide.Buy">
            <summary>
            Buy.
            </summary>
        </member>
        <member name="F:Spreads.DataTypes.TradeSide.Sell">
            <summary>
            Sell.
            </summary>
        </member>
        <member name="T:Spreads.DataTypes.SmallDecimal">
             <summary>
             A blittable 64-bit structure to store small(ish) fixed-point decimal values with precision up to 16 digits.
             It is implemented similarly to <see cref="T:System.Decimal"/> and only uses Int56 to stores significant digits
             instead of Int96 in <see cref="T:System.Decimal"/>. All conversion to and from other numeric types and string
             are done via <see cref="T:System.Decimal"/>.
            
             <para />
            
             Note that this is not IEEE 754-2008 decimal64 but a smaller counterpart
             to <see cref="T:System.Decimal"/> that is easy to implement cross-platform and
             is useful for storing small precise values such as prices or small
             quantities such as Ethereum wei.
             This is also not DEC64 (http://dec64.com/) that has similar design but
             different binary layout.
            
             </summary>
             <remarks>
            
             Binary layout:
            
             ```
              0                   1                   2                   3
              0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             |S|NaN|  Scale  |                  UInt56                       |
             +-------------------------------+-+-+---------------------------+
             ```
             <para />
            
             S - sign.
            
             <para />
            
             NaN - when both bits are set then the value is not a valid SmallDecimal and is
             equivalent to <see cref="F:System.Double.NaN"/> or <see cref="F:System.Double.PositiveInfinity"/>
             or or <see cref="F:System.Double.NegativeInfinity"/>. Used only when converting
             from <see cref="T:System.Double"/> or <see cref="T:System.Single"/>.
            
             <para />
            
             Scale - 0-28 power of 10 to divide Int56 to get a value.
            
             </remarks>
        </member>
        <member name="F:Spreads.DataTypes.SmallDecimal.DecCalc.ulomidLE">
            <summary>
            The low and mid fields combined in little-endian order
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.#ctor(System.Decimal,System.Int32,System.MidpointRounding,System.Boolean)">
             <summary>
            
             </summary>
             <param name="value">Decimal value.</param>
             <param name="decimals">The number of decimal places in the return value.</param>
             <param name="rounding">Rounding option.</param>
             <param name="truncate">
             True means precision loss is allowed by reducing decimals number.
             False means the constructor will throw an
             exception if it is not possible to store <paramref name="value"/>
             without precision loss
             </param>
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.CompareTo(Spreads.DataTypes.SmallDecimal)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.Equals(Spreads.DataTypes.SmallDecimal)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.ToString">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.GetTypeCode">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.ToBoolean(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.ToChar(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.ToSByte(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.ToByte(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.ToInt16(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.ToUInt16(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.ToInt32(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.ToUInt32(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.ToInt64(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.ToUInt64(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.ToSingle(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.ToDouble(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.ToDecimal(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.ToDateTime(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.ToString(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.SmallDecimal.ToType(System.Type,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="T:Spreads.DataTypes.Stat1`1">
            <summary>
            Count and sum.
            </summary>
        </member>
        <member name="T:Spreads.DataTypes.Stat2`1">
            <summary>
            Count, sum and variance.
            </summary>
        </member>
        <member name="F:Spreads.DataTypes.Stat2`1._endValue">
            <remarks>
            For in-place z-score calculation, otherwise would need Zip to original.
            </remarks>
        </member>
        <member name="F:Spreads.DataTypes.Stat2`1._mean">
            <remarks>
            Division is expensive, keeping it saves one division per each operation.
            </remarks>
        </member>
        <member name="P:Spreads.DataTypes.Stat2`1.Count">
            <summary>
            Count.
            </summary>
        </member>
        <member name="P:Spreads.DataTypes.Stat2`1.Sum">
            <summary>
            Sum.
            </summary>
        </member>
        <member name="P:Spreads.DataTypes.Stat2`1.Sum2">
            <summary>
            Sum of squares.
            </summary>
        </member>
        <member name="P:Spreads.DataTypes.Stat2`1.Variance">
            <summary>
            Unbiased sample variance (using Sum2/(Count-1), same as Excel's VAR.S function).
            </summary>
        </member>
        <member name="P:Spreads.DataTypes.Stat2`1.StDev">
            <summary>
            Unbiased sample standard deviation (using Sqrt(Sum2/(Count-1)), same as Excel's STDEV.S function).
            </summary>
        </member>
        <member name="P:Spreads.DataTypes.Stat2`1.ZScore">
            <summary>
            Z-score.
            </summary>
        </member>
        <member name="T:Spreads.DataTypes.Symbol">
            <summary>
            A struct to store up to 16 UTF8 chars.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Symbol.#ctor(System.String)">
            <summary>
            Symbol constructor.
            </summary>
            <param name="symbol">A string with byte length less or equal to 16.</param>
        </member>
        <member name="M:Spreads.DataTypes.Symbol.Equals(Spreads.DataTypes.Symbol)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Symbol.ToString">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Symbol.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Symbol.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Symbol.op_Equality(Spreads.DataTypes.Symbol,Spreads.DataTypes.Symbol)">
            <summary>
            Equals operator.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Symbol.op_Inequality(Spreads.DataTypes.Symbol,Spreads.DataTypes.Symbol)">
            <summary>
            Not equals operator.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Symbol.AsSpan">
            <summary>
            Get Symbol as bytes Span.
            </summary>
        </member>
        <member name="T:Spreads.DataTypes.Symbol32">
            <summary>
            A struct to store up to 64 UTF8 chars.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Symbol32.#ctor(System.String)">
            <summary>
            Symbol constructor.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Symbol32.Equals(Spreads.DataTypes.Symbol32)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Symbol32.ToString">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Symbol32.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Symbol32.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Symbol32.op_Equality(Spreads.DataTypes.Symbol32,Spreads.DataTypes.Symbol32)">
            <summary>
            Equals operator.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Symbol32.op_Inequality(Spreads.DataTypes.Symbol32,Spreads.DataTypes.Symbol32)">
            <summary>
            Not equals operator.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Symbol32.AsSpan">
            <summary>
            Get Symbol as bytes Span.
            </summary>
        </member>
        <member name="T:Spreads.DataTypes.Symbol64">
            <summary>
            A struct to store up to 64 UTF8 chars.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Symbol64.#ctor(System.String)">
            <summary>
            Symbol constructor.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Symbol64.Equals(Spreads.DataTypes.Symbol64)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Symbol64.ToString">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Symbol64.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Symbol64.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Symbol64.op_Equality(Spreads.DataTypes.Symbol64,Spreads.DataTypes.Symbol64)">
            <summary>
            Equals operator.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Symbol64.op_Inequality(Spreads.DataTypes.Symbol64,Spreads.DataTypes.Symbol64)">
            <summary>
            Not equals operator.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Symbol64.AsSpan">
            <summary>
            Get Symbol as bytes Span.
            </summary>
        </member>
        <member name="T:Spreads.DataTypes.Symbol128">
            <summary>
            A struct to store up to 128 UTF8 chars.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Symbol128.#ctor(System.String)">
            <summary>
            Symbol constructor.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Symbol128.Equals(Spreads.DataTypes.Symbol128)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Symbol128.ToString">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Symbol128.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Symbol128.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Symbol128.op_Equality(Spreads.DataTypes.Symbol128,Spreads.DataTypes.Symbol128)">
            <summary>
            Equals operator.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Symbol128.op_Inequality(Spreads.DataTypes.Symbol128,Spreads.DataTypes.Symbol128)">
            <summary>
            Not equals operator.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Symbol128.AsSpan">
            <summary>
            Get Symbol as bytes Span.
            </summary>
        </member>
        <member name="T:Spreads.DataTypes.Symbol256">
            <summary>
            A struct to store up to 256 UTF8 chars.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Symbol256.#ctor(System.String)">
            <summary>
            Symbol constructor.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Symbol256.Equals(Spreads.DataTypes.Symbol256)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Symbol256.ToString">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Symbol256.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Symbol256.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Spreads.DataTypes.Symbol256.op_Equality(Spreads.DataTypes.Symbol256,Spreads.DataTypes.Symbol256)">
            <summary>
            Equals operator.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Symbol256.op_Inequality(Spreads.DataTypes.Symbol256,Spreads.DataTypes.Symbol256)">
            <summary>
            Not equals operator.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Symbol256.AsSpan">
            <summary>
            Get Symbol as bytes Span.
            </summary>
        </member>
        <member name="T:Spreads.DataTypes.Timestamp">
             <summary>
             A Timestamp stored as UTC nanos since Unix epoch.
             </summary>
             <remarks>
             Timestamp is used as a much faster and convenient replacement of <see cref="P:Spreads.DataTypes.Timestamp.DateTime"/>
             in Spreads, because DateTime is very problematic data structure in .NET.
            
             <para />
            
             First, it has <see cref="T:System.DateTimeKind"/>
             property that has, in our opinion, meaningless and unusable value <see cref="F:System.DateTimeKind.Local"/>. When
             a value of this kind is serialized it doesn't have any meaning outside the serializer machine.
             <see cref="F:System.DateTimeKind.Utc"/> and <see cref="F:System.DateTimeKind.Unspecified"/> have different binary layout,
             but there is probably no meaningful way to treat unspecified kind other than UTC. The kind bits in
             <see cref="P:Spreads.DataTypes.Timestamp.DateTime"/> add no value but make the same values binary incompatible.
             <see cref="T:Spreads.DataTypes.Timestamp"/> time is always UTC and time zone information is supposed to be stored
             separately.
            
             <para />
            
             Second, <see cref="P:Spreads.DataTypes.Timestamp.DateTime"/> structure has <see cref="F:System.Runtime.InteropServices.LayoutKind.Auto"/>, even though internally
             it is just <see cref="T:System.UInt64"/> and millions of code lines depend on its binary layout so that
             Microsoft is unlikely to change it ever. The auto layout makes <see cref="P:Spreads.DataTypes.Timestamp.DateTime"/>  and
             every other structure that contains it as a field not blittable. <see cref="T:Spreads.DataTypes.Timestamp"/> is blittable
             and very fast. See our serialization documentation on why it is a big deal. (TODO link).
            
             <para />
            
             <see cref="T:Spreads.DataTypes.Timestamp"/> is serialized to JSON as decimal string with seconds, e.g. "1552315408.792075401".
             This is one of the formats supported by <see href="https://www.npmjs.com/package/microtime">microtime</see>
             package. A value is stored as string to preserve precision, but in JavaScript it could be trivially
             converted to a number with plus sign `+"123456789.123456789"`. If you need to keep nanoseconds
             precision in JavaScript then split the string by dot and use two values separately.
             Deserializer supports decimal as a number as well as a string.
            
             <para />
            
             <see cref="T:Spreads.Threading.TimeService"/> provides unique monotonic timestamps and could work across processes via shared memory.
            
             <para />
             Range:
             ```
             2^63: 9,223,372,036,854,780,000
             Nanos per day: 86,400,000,000,000 (2^47)
             Nanos per year: 31,557,600,000,000,000 (2^55)
             292 years of nanos in 2^63 is ought to be enough for everyone living now and their grand grand grandchildren.
             ```
             </remarks>
             <seealso cref="T:Spreads.Threading.TimeService"/>
        </member>
        <member name="P:Spreads.DataTypes.Timestamp.NowSeconds">
            <summary>
            Compared to Now.Seconds this uses `DateTime.Now.ToUniversalTime()` instead of `DateTime.UtcNow`.
            The former call is slightly faster but less precise.
            </summary>
        </member>
        <member name="P:Spreads.DataTypes.Timestamp.TimeSpan">
            <summary>
            Returns <see cref="P:Spreads.DataTypes.Timestamp.TimeSpan"/> with nanoseconds *rounded up* to ticks.
            </summary>
        </member>
        <member name="M:Spreads.DataTypes.Timestamp.CompareTo(Spreads.DataTypes.Timestamp)">
            <inheritdoc />
        </member>
        <member name="T:Spreads.DataTypes.Timestamped`1">
            <summary>
            A value with a <see cref="F:Spreads.DataTypes.Timestamped`1.Timestamp"/>.
            </summary>
        </member>
        <member name="T:Spreads.DataTypes.UUID">
            <summary>
            GUID-like structure that do not promise any RFC compliance and
            could be treated as securely random 16 bytes.
            </summary>
        </member>
        <member name="T:Spreads.PeriodTick">
            <summary>
            Indicates where a tick/instant is relative to a period.
            </summary>
        </member>
        <member name="F:Spreads.PeriodTick.PointInTime">
            <summary>
            Point in time. E.g. close price is instant even though it could be regular (every second).
            </summary>
        </member>
        <member name="F:Spreads.PeriodTick.EndOfPeriod">
            <summary>
            End of period.
            </summary>
        </member>
        <member name="F:Spreads.PeriodTick.StartOfPeriod">
            <summary>
            Start of period.
            </summary>
        </member>
        <member name="F:Spreads.PeriodTick.EntirePeriod">
            <summary>
            Entire period.
            </summary>
        </member>
        <member name="T:Spreads.UnitPeriod">
            <summary>
            Base unit of a period
            </summary>
        </member>
        <member name="F:Spreads.UnitPeriod.Eternity">
            <summary>
            Static or constant
            </summary>
        </member>
        <member name="P:Spreads.TimeSeriesInfo.StrictUtc">
            <summary>
            When set to true, undefined (null) TZ value cannot be used with other time zones.
            Binary false values assumes that users know what they are doing and series with undefined
            time zones could be used with series with any time zone.
            </summary>
        </member>
        <member name="P:Spreads.TimeSeriesInfo.TZ">
            <summary>
            Time zone in <see href="https://en.wikipedia.org/wiki/Tz_database">tz database</see> format.
            </summary>
            <remarks>Null is undefined.</remarks>
        </member>
        <member name="T:Spreads.SpreadsException">
            <summary>
            Exceptions related to data integrity and other Spreads-specific logic.
            </summary>
        </member>
        <member name="T:Spreads.OutOfOrderKeyException`1">
            <summary>
            This exception is thrown during a cursor movements when new data could affect cursor values:
            e.g. data was updated at a key before the current cursor position and the cursor is moving forward
            or the cursor depends on the past.
            </summary>
            <remarks>
            It is easy to recover from this exception using the cursor MoveAt method and CurrentKey/NewKey properties
            of this exception. E.g. MoveAt(ex.CurrentKey, Lookup.GT) in a catch block is equivalent to ignoring
            the exception and continuing to MoveNextAsync.
            To replay values that could have been altered by an out-of-order data point, one could use MoveAt(ex.NewKey, Lookup.EQ).
            It is the responsibility of cursor consumer to recover from this exception, cursors should not implement any "smart"
            behavior unless it is a part of cursor definition and is explicitly documented.
            The state of cursor is undefined and invalid after the exception is thrown.
            </remarks>
        </member>
        <member name="P:Spreads.OutOfOrderKeyException`1.CurrentKey">
            <summary>
            Key/value before arrival of out-of-order data point
            </summary>
        </member>
        <member name="T:Spreads.Mutability">
            <summary>
            Mutability of underlying data source.
            </summary>
        </member>
        <member name="F:Spreads.Mutability.ReadOnly">
            <summary>
            Data cannot be modified.
            </summary>
        </member>
        <member name="F:Spreads.Mutability.AppendOnly">
            <summary>
            Data could be added without changing existing order. Segments of existing data could be treated as <see cref="F:Spreads.Mutability.ReadOnly"/>.
            </summary>
        </member>
        <member name="F:Spreads.Mutability.Mutable">
            <summary>
            Data could be modified at any place and order of existing data could change.
            </summary>
        </member>
        <member name="T:Spreads.KeySorting">
            <summary>
            Determines how key order is enforced and if a data stream could be opened as series in case of <see cref="F:Spreads.KeySorting.Strong"/> sorting
            or efficient search by keys is possible in case of <see cref="F:Spreads.KeySorting.Weak"/> sorting.
            </summary>
        </member>
        <member name="F:Spreads.KeySorting.NotSorted">
            <summary>
            Key sorting is not enforced but it may still be tracked and keys could be strongly or weakly sorted by accident.
            </summary>
        </member>
        <member name="F:Spreads.KeySorting.Weak">
            <summary>
            Keys are weakly monotonically sorted according to <see cref="F:Spreads.KeyComparer`1.Default"/> comparer.
            Repeating equal keys are possible.
            Search by a key always returns the first item with the same key (or throws NotSupportedException).
            </summary>
        </member>
        <member name="F:Spreads.KeySorting.Strong">
            <summary>
            Keys are strictly monotonically sorted according to <see cref="F:Spreads.KeyComparer`1.Default"/> comparer.
            No repeating keys are possible.
            </summary>
        </member>
        <member name="F:Spreads.ContainerLayout.None">
            <summary>
            Instance having this flag is none of the containers but a data stream or projection.
            It does not own DataBlock/DataBlockSource and does not inherit from BaseContainer.
            </summary>
        </member>
        <member name="F:Spreads.ContainerLayout.Matrix">
            <summary>
            TODO (review)
            Only contiguous (stride = 1) Values and
            borrowed columns pointing to the values storage with offset/stride IF NUMBER OF COLUMNS > 1.
            TODO (?) this is not required for virtual/projection? For a single column values with stride 1 is the column.
            </summary>
        </member>
        <member name="F:Spreads.ContainerLayout.Series">
            <summary>
            Series is a matrix with single column and row index.
            </summary>
        </member>
        <member name="F:Spreads.ContainerLayout.SeriesX">
            <summary>
            TODO What series owns storage but is not single-column matrix? Maybe a projection with the same keys but lazy values?
            E.g. vector math could use SIMD, but only for horizontal operations and this could be done via MoveNextBatch.
            Frame/Panel could return columns with some projection.
            </summary>
        </member>
        <member name="F:Spreads.ContainerLayout.Panel">
             <summary>
            
             </summary>
        </member>
        <member name="T:Spreads.IKeyComparer`1">
            <summary>
            <see cref="T:System.Collections.Generic.IComparer`1"/> with optional <see cref="P:Spreads.IKeyComparer`1.IsDiffable"/>, <see cref="M:Spreads.IKeyComparer`1.Diff(`0,`0)"/> and <see cref="M:Spreads.IKeyComparer`1.Add(`0,System.Int64)"/> members.
            </summary>
        </member>
        <member name="P:Spreads.IKeyComparer`1.IsDiffable">
            <summary>
            True if a type T supports <see cref="M:Spreads.IKeyComparer`1.Diff(`0,`0)"/> and <see cref="M:Spreads.IKeyComparer`1.Add(`0,System.Int64)"/> methods.
            </summary>
        </member>
        <member name="M:Spreads.IKeyComparer`1.Add(`0,System.Int64)">
            <summary>
            If Diff(A,B) = X, then Add(A,X) = B, this is an opposite method for Diff.
            </summary>
        </member>
        <member name="M:Spreads.IKeyComparer`1.Diff(`0,`0)">
            <summary>
            Returns int64 distance between two values.
            </summary>
            <remarks>
            This method could be used for <see cref="M:System.Collections.Generic.IComparer`1.Compare(`0,`0)"/> implementation,
            but must be checked for int overflow (e.g. compare Diff result to 0L instead of int cast).
            </remarks>
        </member>
        <member name="T:Spreads.KeyComparer`1">
            <summary>
            Fast IComparer implementation.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Spreads.KeyComparer`1.IsBuiltInNumericType">
            <summary>
            Returns true for built-in types that are numbers or could be represented as numbers via <see cref="T:Spreads.Native.IInt64Diffable`1"/>.
            </summary>
        </member>
        <member name="F:Spreads.KeyComparer`1.IsIComparable">
            <summary>
            Returns true for types that implement <see cref="T:System.IComparable`1"/> interface.
            </summary>
        </member>
        <member name="F:Spreads.KeyComparer`1.IsIInt64Diffable">
            <summary>
            Returns true for types that implement <see cref="T:Spreads.Native.IInt64Diffable`1"/> interface.
            </summary>
        </member>
        <member name="F:Spreads.KeyComparer`1.Default">
            <summary>
            Binary instance of a KeyComparer for type T.
            </summary>
        </member>
        <member name="P:Spreads.KeyComparer`1.IsDiffable">
            <summary>
            Returns true for types that implement <see cref="T:Spreads.Native.IInt64Diffable`1"/> interface or are <see cref="F:Spreads.KeyComparer`1.IsBuiltInNumericType"/>.
            </summary>
        </member>
        <member name="P:Spreads.KeyComparer`1.IsDiffableSafe">
            <summary>
            True is we could safely prefer interpolation search over binary search. Mostly known types for now.
            </summary>
        </member>
        <member name="M:Spreads.KeyComparer`1.Create(System.Collections.Generic.IComparer{`0})">
            <summary>
            Get a new or default instance of KeyComparer.
            </summary>
        </member>
        <member name="M:Spreads.KeyComparer`1.Create(Spreads.IKeyComparer{`0})">
            <summary>
            Get a new or default instance of KeyComparer.
            </summary>
        </member>
        <member name="M:Spreads.KeyComparer`1.Compare(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.KeyComparer`1.Add(`0,System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.KeyComparer`1.Diff(`0,`0)">
            <summary>
            Returns Int64 distance between two values.
            </summary>
        </member>
        <member name="M:Spreads.KeyComparer`1.Equals(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.KeyComparer`1.GetHashCode(`0)">
            <summary>
            GetHashCode is not supported.
            </summary>
        </member>
        <member name="T:Spreads.KVPComparer`2">
            <summary>
            Fast IComparer for KeyValuePair.
            </summary>
        </member>
        <member name="M:Spreads.KVPComparer`2.#ctor(Spreads.KeyComparer{`0},Spreads.KeyComparer{`1})">
            <summary>
            Create a KVP comparer that compares keys and values.
            </summary>
        </member>
        <member name="M:Spreads.KVPComparer`2.#ctor(Spreads.KeyComparer{`0})">
            <summary>
            Create a KVP comparer that only compares keys. With this constructor values are ignored.
            </summary>
        </member>
        <member name="M:Spreads.KVPComparer`2.Compare(System.Collections.Generic.KeyValuePair{`0,`1},System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Spreads.KVPComparer`2.Equals(System.Collections.Generic.KeyValuePair{`0,`1},System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Spreads.KVPComparer`2.GetHashCode(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            GetHashCode is not supported.
            </summary>
        </member>
        <member name="T:Spreads.KeyEqualityComparer`1">
            <summary>
            Fast IEqualityComparer implementation that only supports IEquatable types or default equality comparison.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Spreads.KeyEqualityComparer`1.Default">
            <summary>
            Binary instance of a KeyEqualityComparer for type T.
            </summary>
        </member>
        <member name="M:Spreads.KeyEqualityComparer`1.Equals(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:Spreads.KeyEqualityComparer`1.GetHashCode(`0)">
            <summary>
            GetHashCode is not supported.
            </summary>
        </member>
        <member name="T:Spreads.Lookup">
            <summary>
            Direction to lookup data or move from a starting point.
            </summary>
        </member>
        <member name="F:Spreads.Lookup.LT">
            <summary>
            Less than.
            </summary>
        </member>
        <member name="F:Spreads.Lookup.LE">
            <summary>
            Less or equal.
            </summary>
        </member>
        <member name="F:Spreads.Lookup.EQ">
            <summary>
            Equal.
            </summary>
        </member>
        <member name="F:Spreads.Lookup.GE">
            <summary>
            Greater or equal.
            </summary>
        </member>
        <member name="F:Spreads.Lookup.GT">
            <summary>
            Greater than.
            </summary>
        </member>
        <member name="M:Spreads.LookupHelpers.ComplementAdjustment(Spreads.Lookup)">
            <summary>
            Returns 1 if Lookup is LT or LE.
            </summary>
        </member>
        <member name="M:Spreads.LookupHelpers.NeqOffset(Spreads.Lookup)">
            <summary>
            Returns offset to add to found index when equality is not valid.
            </summary>
        </member>
        <member name="T:Spreads.Opt">
            <summary>
            Helper methods for <see cref="T:Spreads.Opt`1"/>.
            </summary>
        </member>
        <member name="M:Spreads.Opt.Present``1(``0)">
            <summary>
            Crate new <see cref="T:Spreads.Opt`1"/> value.
            </summary>
            <example>
            Avoid type specification of <see cref="T:Spreads.Opt`1"/> constructor and just use the <see cref="M:Spreads.Opt.Present``1(``0)"/>
            method that infers the type and creates a new <see cref="T:Spreads.Opt`1"/> value with the given present value.
            <code>
            public static Opt&lt;int&gt; Example()
            {
                return Opt.Present(1);
            }
            </code>
            </example>
        </member>
        <member name="T:Spreads.Opt`1">
            <summary>
            A minimal implementation of the Option type. <typeparamref name="T"/> must implement <see cref="T:System.IEquatable`1"/> for custom equality.
            </summary>
        </member>
        <member name="P:Spreads.Opt`1.Missing">
            <summary>
            Missing value.
            </summary>
        </member>
        <member name="M:Spreads.Opt`1.#ctor(`0@)">
            <summary>
            Create new optional value with a given present value.
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:Spreads.Opt`1.IsPresent">
            <summary>
            True if a value is present.
            </summary>
        </member>
        <member name="P:Spreads.Opt`1.IsMissing">
            <summary>
            True if a value is missing.
            </summary>
        </member>
        <member name="P:Spreads.Opt`1.Present">
            <summary>
            Present value.
            </summary>
        </member>
        <member name="M:Spreads.Opt`1.LargerOrMissing(Spreads.Opt{`0},Spreads.Opt{`0},Spreads.KeyComparer{`0})">
            <summary>
            Return a larger Opt value or Missing if both are missing. Missing value is treated as smaller than a present value.
            </summary>
        </member>
        <member name="M:Spreads.Opt`1.SmallerOrMissing(Spreads.Opt{`0},Spreads.Opt{`0},Spreads.KeyComparer{`0})">
            <summary>
            Return a smaller Opt value or Missing if both are missing. Missing value is treated as larger than a present value.
            </summary>
        </member>
        <member name="M:Spreads.Opt`1.op_Explicit(Spreads.Opt{`0})~`0">
            <summary>
            Explicit cast from <see cref="T:Spreads.Opt`1"/> to a value of type <typeparamref name="T"/>.
            Return the default value if <see cref="T:Spreads.Opt`1"/> is missing.
            </summary>
        </member>
        <member name="P:Spreads.Serialization.BinarySerializationAttribute.PreferBlittable">
            <summary>
            Prefer blittable layout if possible. Sometimes a generic type could implement (or have registered) IBinaryConverter interface
            but for certain concrete types still be blittable. When this property is true, we
            ignore the IBinaryConverter interface when a generic type is blittable but implements that interface (or has it registered).
            </summary>
        </member>
        <member name="P:Spreads.Serialization.BinarySerializationAttribute.BlittableSize">
            <summary>
            When this property is positive, the type must be blittable with the specified size,
            otherwise Environment.FailFast method is called and the application is terminated.
            </summary>
            <remarks>
            StructLayout.Size has the same behavior.
            </remarks>
        </member>
        <member name="T:Spreads.Serialization.BinarySerializer`1">
            <summary>
            Serialize a generic object T to a pointer, prefixed with version and length.
            </summary>
        </member>
        <member name="P:Spreads.Serialization.BinarySerializer`1.KnownTypeId">
            <summary>
            An type id that must be unique in user application.
            Could be stored separately from payload and checked during deserialization.
            Not used at the moment.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.BinarySerializer`1.SizeOf(`0@,Spreads.Buffers.BufferWriter)">
             <summary>
             Returns the size of serialized value payload.
             When <paramref name="payload"/> parameter is not null this method should additionally
             serialize the value into <paramref name="payload"/> <see cref="T:Spreads.Buffers.BufferWriter"/>.
             </summary>
            
             <remarks>
            
             For variable size types, performing actual serialization to a temp buffer is often the only
             way to calculate the payload size. Write to <paramref name="payload"/> directly in that case
             and do not use a separate buffer. The <paramref name="payload"/> buffer content will then be used
             by <see cref="T:Spreads.Serialization.BinarySerializer"/> Write methods instead of performing serialization the second time.
            
             <para />
            
             Do not include length prefix in payload because <see cref="T:Spreads.Serialization.BinarySerializer"/> does so
             automatically and guarantees than <see cref="M:Spreads.Serialization.BinarySerializer`1.Read(Spreads.Buffers.DirectBuffer,`0@)"/> method will receive the source
             buffer of exact payload length.
            
             </remarks>
             <param name="value">Value to serialize.</param>
             <param name="payload">If not <see cref="P:Spreads.Serialization.BinarySerializer`1.FixedSize"/> then this parameter is not null
             and serializer must write actual payload into it.</param>
             <returns></returns>
        </member>
        <member name="M:Spreads.Serialization.BinarySerializer`1.Write(`0@,Spreads.Buffers.DirectBuffer)">
            <summary>
            Serializes a value to the <paramref name="destination"/> buffer.
            This method is called by <see cref="T:Spreads.Serialization.BinarySerializer"/> only when <see cref="M:Spreads.Serialization.BinarySerializer`1.SizeOf(`0@,Spreads.Buffers.BufferWriter)"/> returned
            positive length with default/empty temporaryBuffer.
            </summary>
            <param name="value">A value to serialize.</param>
            <param name="destination">A buffer to write to. Has the length returned from <see cref="M:Spreads.Serialization.BinarySerializer`1.SizeOf(`0@,Spreads.Buffers.BufferWriter)"/></param>
        </member>
        <member name="M:Spreads.Serialization.BinarySerializer`1.Read(Spreads.Buffers.DirectBuffer,`0@)">
            <summary>
            Reads a value of type <typeparamref name="T"/> from <paramref name="source"/>,
            returns the number of bytes consumed.
            </summary>
            <param name="source">A buffer to read from.</param>
            <param name="value">Deserialized value.</param>
            <returns>Number of bytes consumed. Must be equal to <paramref name="source"/> buffer length on success.
            Any other value is assumed a failure.</returns>
        </member>
        <member name="M:Spreads.Serialization.BinarySerializer.Decompress(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},Spreads.Serialization.CompressionMethod)">
            <summary>
            Source must be of exact compressed payload size, which must be stored somewhere (e.g. in custom header). Use Slice() to trim source to the exact size.
            Destination must have enough size for uncompressed payload.
            This method returns number of uncompressed bytes written to the destination buffer.
            Non-positive return value means an error, exact value if opaque as of now (impl. detail: it returns native error code for GZip/LZ4, but that could change).
            </summary>
        </member>
        <member name="M:Spreads.Serialization.BinarySerializer.WarmUp``1">
            <summary>
            Initializes all static readonly fields used in serialization so that they are treated as JIT constants
            or known sealed classes afterwards.
            Call this from anywhere before using <see cref="T:Spreads.Serialization.BinarySerializer"/> for type <typeparamref name="T"/>.
            For fixed size tuples performance difference could be 2x.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.BinarySerializer.PayloadLengthSize">
            <summary>
            Size of payload length prefix is 4 bytes (<see cref="T:System.Int32"/>).
            </summary>
        </member>
        <member name="M:Spreads.Serialization.BinarySerializer.FixedSize``1">
            <summary>
            Returns a positive value for fixed serialized size of the type <typeparamref name="T"/>
            or a meaningless negative value for variable size type. Zero value is invalid.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.BinarySerializer.SizeOf``1(``0@,Spreads.Buffers.BufferWriter@,Spreads.Serialization.SerializationFormat)">
             <summary>
            
             Returns the size of serialized value payload plus <see cref="F:Spreads.Serialization.DataTypeHeader.Size"/>
             plus <see cref="F:Spreads.Serialization.BinarySerializer.PayloadLengthSize"/> if payload is not fixed size.
             You could use the returned value to allocate a buffer for subsequent
             write operation - it must have capacity greater or equal to the return
             value of <see cref="M:Spreads.Serialization.BinarySerializer.SizeOf``1(``0@,Spreads.Buffers.BufferWriter@,Spreads.Serialization.SerializationFormat)"/>.
            
             <para />
            
             When serialized payload length is only known after serialization, which is the case for variable size types and many containers,
             this method serializes the value into <paramref name="payload"/>.
             The buffer <paramref name="payload.temporaryBuffer.temporaryBuffer"/> is owned by the caller, ownership is transferred to a Write method that disposes the buffer.
            
             <para />
            
             Returned <paramref name="payload.actualFormat.actualFormat"/> could differ from <paramref name="preferredFormat"/>
             when preferred format is binary but there is no custom binary serializer
             or if preferred format is compressed but payload length is less than <see cref="P:Spreads.Settings.CompressionStartFrom"/>.
            
             </summary>
             <param name="value">A value to serialize.</param>
             <param name="payload">A buffer with serialized payload and actual format. (optional, for cases when the serialized size is not known without performing serialization)</param>
             <param name="preferredFormat">Preferred serialization format.</param>
        </member>
        <member name="F:Spreads.Serialization.BinarySerializerErrorCode.NotEnoughCapacity">
            <summary>
            Destination buffer is smaller than serialized payload size.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.BinarySerializerErrorCode.HeaderMismatch">
            <summary>
            Value header does not match expected header.
            </summary>
        </member>
        <member name="T:Spreads.Serialization.DataTypeHeader">
            <summary>
            DataType header for serialized data. First byte contains serialization format flags.
            Bytes 1-3 describe the serialized type and its subtypes (for composites and containers).
            Type information is stored as <see cref="T:Spreads.Serialization.TypeEnumOrFixedSize"/> 1-byte struct.
            </summary>
            <remarks>
            ```
            0                   1                   2                   3
            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            | Version+Flags |     TEOFS     |     TEOFS1    |     TEOFS2    |
            +---------------------------------------------------------------+
            ```
            </remarks>
        </member>
        <member name="F:Spreads.Serialization.DataTypeHeader.TupleNCount">
            <summary>
            Count for <see cref="F:Spreads.Serialization.TypeEnum.TupleN"/> and <see cref="F:Spreads.Serialization.TypeEnum.TupleTN"/>
            is stored in the slot <see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS1"/> as <see cref="T:System.Byte"/>.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.DataTypeHeader.TupleTNTeofs">
            <summary>
            Type of <see cref="F:Spreads.Serialization.TypeEnum.TupleTN"/> elements is stored in the slot <see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS2"/>
            </summary>
        </member>
        <member name="F:Spreads.Serialization.DataTypeHeader.TupleNFixedSize">
            <summary>
            Fixed size of <see cref="F:Spreads.Serialization.TypeEnum.TupleN"/> is stored in the slot <see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS2"/>.
            Non-zero only if all <see cref="F:Spreads.Serialization.TypeEnum.TupleN"/> are of fixed size.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.DataTypeHeader.UserFixedSize">
            <summary>
            Fixed size of <see cref="F:Spreads.Serialization.TypeEnum.UserType"/> or <see cref="F:Spreads.Serialization.TypeEnum.FixedSize"/> type is stored as <see cref="T:System.Int16"/>
            in the two slots <see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS1"/> and <see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS2"/>.
            </summary>
        </member>
        <member name="P:Spreads.Serialization.DataTypeHeader.FixedSize">
            <summary>
            Positive number if a type has fixed size.
            </summary>
        </member>
        <member name="T:Spreads.Serialization.DecimalDelta">
            <summary>
            Diffable wrapper for decimal type
            </summary>
        </member>
        <member name="T:Spreads.Serialization.ContainerSchema">
            <summary>
            DTO for a container schema.
            </summary>
        </member>
        <member name="T:Spreads.Serialization.TypeSchema">
            <summary>
            DTO for a type schema.
            </summary>
        </member>
        <member name="T:Spreads.Serialization.SerializationFormat">
             <summary>
             Preferred serialization method. Binary is used only for blittable types or when IBinaryConverter is present.
             Compression is done only when compressed size is not larger than the original size (usually it works, but it is
             possible that data will not be compressed and providing this enum to serializer means best-effort, not a guarantee).
            
             Binary serialization format. Serialized data always has a header describing the method of
             binary serialization. The data could be Json, but because of the header it is not directly
             consumable by e.g. browsers. However, for Json/JsonGZip cases the only difference is
             the header and the rest payload could be directly sent to a browser expecting 'application/json'
             MIME type.
             </summary>
             <remarks>
             JsonGZip:
             Objects are converted to Json and compressed with JsonGZip method. This format is compatible with raw
             http payload with 'Accept-encoding: gzip' headers past the 8 bytes header.
            
             BinaryLz4/Zstd:
             Binary is stored as blittable representation with Blosc byteshuffle for arrays with fixed-size elements.
             Then serialized (and byteshuffled) buffer is compressed with LZ4 (super fast but lower compression) or
             Zstd (still fast and high compression, preferred method) if compression gives smaller size.
             Actual buffer layout is type dependent.
            
             Serialized buffer has a header with a flag indicating the format and
             whether or not the buffer is compressed. Some data types are stored as deltas
             with diffing performed before byteshuffling and the header must have such flag as well.
            
             SerializationFormat should not be confused with Transport/Protocol format:
             * Text trasport/protocol supports only JSON and the payload is plain or gzipped JSON that
               could be consumed by browsers or http servers (with headers indicating the actual format - compressed or not).
             * Binary trasport/protocol cannot be consumed directly by browsers or http servers. The exact data layout of payload
               depends on data type and is encoded in a 4 (+ optional 4 bytes length for variable sized data) bytes header.
               Data could be serialized as JSON (mostly for convenience if a type is not used a lot and not blittable)
               but it is still a binary format, though one that could be trivially converted to JSON.
             </remarks>
        </member>
        <member name="F:Spreads.Serialization.SerializationFormat.Binary">
            <summary>
            Custom binary format without compression.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.SerializationFormat.BinaryGZip">
            <summary>
            Well-balanced compression with good x-plat support.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.SerializationFormat.BinaryLz4">
            <summary>
            Fast compression, larger size.
            </summary>
            <remarks>
            Use blittable reprezentation, byteshuffle with Blosc where possibe,
            fallback to JSON for non-blittable types and compress with BinaryLz4.
            </remarks>
        </member>
        <member name="F:Spreads.Serialization.SerializationFormat.BinaryZstd">
            <summary>
            Good compression ratio, slower speed.
            </summary>
            <remarks>
            Use blittable reprezentation, byteshuffle with Blosc where possibe,
            fallback to JSON for non-blittable types and compress with BinaryZstd.
            </remarks>
        </member>
        <member name="F:Spreads.Serialization.SerializationFormat.Json">
            <summary>
            Uncompressed JSON
            </summary>
        </member>
        <member name="F:Spreads.Serialization.SerializationFormat.JsonGZip">
            <summary>
            Serialize to JSON and compress with GZip method.
            </summary>
        </member>
        <member name="T:Spreads.Serialization.SerializationThrowHelper">
            <summary>
            Throw helper specific to serialization.
            </summary>
        </member>
        <member name="T:Spreads.Serialization.Serializers.ArraySerializer`1">
            <summary>
            Simple copy of blittable array data. No shuffle.
            </summary>
        </member>
        <member name="T:Spreads.Serialization.Serializers.DateTimeSerializer">
            <summary>
            Fallback serializer that serializes data as JSON but pretends to be a binary one.
            </summary>
        </member>
        <member name="T:Spreads.Serialization.Serializers.FixedProxy`1">
            <summary>
            Implements <see cref="T:Spreads.Serialization.BinarySerializer`1"/> methods as static ones.
            If <see cref="T:Spreads.Serialization.BinarySerializer`1"/> exists then uses it or writes
            a <typeparamref name="T"/> directly, in which case it must be an
            unmanaged struct.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Spreads.Serialization.Serializers.Quote`2">
            <summary>
            Sometimes volume is int (lots), other times it is full decimal (Ethereum wei).
            TODO At least price could always fir into SmallDecimal.
            </summary>
            <typeparam name="TPrice"></typeparam>
            <typeparam name="TVolume"></typeparam>
        </member>
        <member name="T:Spreads.Serialization.Serializers.JsonBinarySerializer`1">
            <summary>
            Fallback serializer that serializes data as JSON but pretends to be a binary one.
            </summary>
        </member>
        <member name="T:Spreads.Serialization.TypeEnum">
             <summary>
             Known types and containers enumeration.
             </summary>
             <remarks>
             The goal of this enumeration is to have a unique small ids for frequently used
             types, provision ids for likely future types and set ids to main containers.
            
             <para />
            
             Serialized data or non-generic containers such as <see cref="F:Spreads.Serialization.TypeEnum.Variant"/>
             have <see cref="T:Spreads.Serialization.DataTypeHeader"/>
             that contains 3 <see cref="T:Spreads.Serialization.TypeEnum"/> slots that describe the data.
            
             <para />
            
             Integer types are always serialized as little-endian.
             Big-endian is completely not and won't be supported in foreseeable future.
             </remarks>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.None">
            <summary>
            Unit type, meaningful absence of any value.
            Compare to default/null which are a special values of some type.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Int8">
            <summary>
            See <see cref="T:System.SByte"/>.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Int16">
            <summary>
            See <see cref="T:System.Int16"/>.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Int32">
            <summary>
            See <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Int64">
            <summary>
            See <see cref="T:System.Int64"/>.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Int128">
             <summary>
            
             </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.UInt8">
            <summary>
            See <see cref="T:System.Byte"/>.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.UInt16">
            <summary>
            See <see cref="T:System.UInt16"/>.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.UInt32">
            <summary>
            See <see cref="T:System.UInt32"/>.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.UInt64">
            <summary>
            See <see cref="T:System.UInt64"/>.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.UInt128">
             <summary>
            
             </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Float16">
            <summary>
            See https://en.wikipedia.org/wiki/Half-precision_floating-point_format.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Float32">
            <summary>
            See <see cref="T:System.Single"/>.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Float64">
            <summary>
            See <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Float128">
            <summary>
            See https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Decimal32">
            <summary>
            See https://en.wikipedia.org/wiki/Decimal32_floating-point_format.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Decimal64">
            <summary>
            See https://en.wikipedia.org/wiki/Decimal64_floating-point_format.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Decimal128">
            <summary>
            See https://en.wikipedia.org/wiki/Decimal128_floating-point_format.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Decimal">
            <summary>
            See <see cref="T:System.Decimal"/>.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.SmallDecimal">
            <summary>
            See <see cref="F:Spreads.Serialization.TypeEnum.SmallDecimal"/>.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Bool">
            <summary>
            See <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Utf16Char">
            <summary>
            See <see cref="T:System.Char"/>
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.UUID">
            <summary>
            See <see cref="F:Spreads.Serialization.TypeEnum.UUID"/>. Could store <see cref="T:System.Guid"/> as well, but there is no restrictions on format.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.DateTime">
            <summary>
            <see cref="F:Spreads.Serialization.TypeEnum.DateTime"/> UTC ticks (100ns intervals since zero) as UInt64
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Timestamp">
            <summary>
            <see cref="F:Spreads.Serialization.TypeEnum.Timestamp"/> as nanoseconds since Unix epoch as UInt64
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Binary">
            <summary>
            Opaque binary string prefixed by <see cref="T:System.Int32"/> length in bytes.
            Alias for <see cref="F:Spreads.Serialization.TypeEnum.Array"/> of <see cref="F:Spreads.Serialization.TypeEnum.UInt8"/>.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Utf8String">
            <summary>
            A Utf8 string prefixed by <see cref="T:System.Int32"/> length in bytes.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Utf16String">
            <summary>
            A Utf16 <see cref="T:System.String"/> prefixed by <see cref="T:System.Int32"/> length in bytes.
            Alias for <see cref="F:Spreads.Serialization.TypeEnum.Array"/> of <see cref="F:Spreads.Serialization.TypeEnum.Utf16Char"/>.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Json">
            <summary>
            Utf8 JSON prefixed by <see cref="T:System.Int32"/> length in bytes.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.TupleTN">
             <summary>
             N ordered elements of the same type with N up to 256 elements.
             </summary>
             <remarks>
             This covers all same-type fixed-size tuples from 1 to 256.
             The number of elements is stored in <see cref="F:Spreads.Serialization.DataTypeHeader.TupleNCount"/> (<see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS1"/>).
             Element type is stored in <see cref="F:Spreads.Serialization.DataTypeHeader.TupleTNTeofs"/> (<see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS2"/>).
            
             ```
             0                   1                   2                   3
             0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             | Version+Flags |    TupleTN    |  TupleTNCount |       T       |
             +---------------------------------------------------------------+
             ```
             If type T is not a scalar (see <see cref="P:Spreads.Serialization.DataTypeHeader.IsScalar"/>)
             then T slot is set to <see cref="F:Spreads.Serialization.TypeEnum.CompositeType"/>.
            
             </remarks>
             <seealso cref="F:Spreads.Serialization.TypeEnum.TupleN"/>
             <seealso cref="F:Spreads.Serialization.TypeEnum.ArrayOfTupleTN"/>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.TupleT2">
            <summary>
            A tuple with two elements of same type.
            </summary>
            <remarks>
            Element type is stored in <see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS1"/>.
            ```
            0                   1                   2                   3
            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            | Version+Flags |    TupleT2    |       T       |      T1?      |
            +---------------------------------------------------------------+
            ```
            If type T is a scalar type (see <see cref="P:Spreads.Serialization.DataTypeHeader.IsScalar"/>) then
            T1 slot is empty. T1 could be a subtype of T if two slots is enough to
            describe the type T. If more than two slots are required to
            describe the type T then T slot is set to <see cref="F:Spreads.Serialization.TypeEnum.CompositeType"/>.
            </remarks>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.TupleT3">
            <summary>
            A tuple with three elements of same type.
            </summary>
            <remarks>
            Element type is stored in <see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS1"/>.
            ```
            0                   1                   2                   3
            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            | Version+Flags |    TupleT3    |       T       |      T1?      |
            +---------------------------------------------------------------+
            ```
            If type T is a scalar type (see <see cref="P:Spreads.Serialization.DataTypeHeader.IsScalar"/>) then
            T1 slot is empty. T1 could be a subtype of T if two slots is enough to
            describe the type T. If more than two slots are required to
            describe the type T then T slot is set to <see cref="F:Spreads.Serialization.TypeEnum.CompositeType"/>.
            </remarks>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.TupleT4">
            <summary>
            A tuple with four elements of same type.
            </summary>
            <remarks>
            Element type is stored in <see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS1"/>.
            ```
            0                   1                   2                   3
            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            | Version+Flags |    TupleT4    |       T       |      T1?      |
            +---------------------------------------------------------------+
            ```
            If type T is a scalar type (see <see cref="P:Spreads.Serialization.DataTypeHeader.IsScalar"/>) then
            T1 slot is empty. T1 could be a subtype of T if two slots is enough to
            describe the type T. If more than two slots are required to
            describe the type T then T slot is set to <see cref="F:Spreads.Serialization.TypeEnum.CompositeType"/>.
            </remarks>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.TupleT5">
            <summary>
            A tuple with five elements of same type.
            </summary>
            <remarks>
            Element type is stored in <see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS1"/>.
            ```
            0                   1                   2                   3
            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            | Version+Flags |    TupleT5    |       T       |      T1?      |
            +---------------------------------------------------------------+
            ```
            If type T is a scalar type (see <see cref="P:Spreads.Serialization.DataTypeHeader.IsScalar"/>) then
            T1 slot is empty. T1 could be a subtype of T if two slots is enough to
            describe the type T. If more than two slots are required to
            describe the type T then T slot is set to <see cref="F:Spreads.Serialization.TypeEnum.CompositeType"/>.
            </remarks>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.TupleT6">
            <summary>
            A tuple with six elements of same type.
            </summary>
            <remarks>
            Element type is stored in <see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS1"/>.
            ```
            0                   1                   2                   3
            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            | Version+Flags |    TupleT6    |       T       |      T1?      |
            +---------------------------------------------------------------+
            ```
            If type T is a scalar type (see <see cref="P:Spreads.Serialization.DataTypeHeader.IsScalar"/>) then
            T1 slot is empty. T1 could be a subtype of T if two slots is enough to
            describe the type T. If more than two slots are required to
            describe the type T then T slot is set to <see cref="F:Spreads.Serialization.TypeEnum.CompositeType"/>.
            </remarks>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Tuple2">
            <summary>
            A tuple with two elements of different types.
            </summary>
            <remarks>
            Element types are stored in <see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS1"/>
            and <see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS2"/>.
            ```
            0                   1                   2                   3
            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            | Version+Flags |     Tuple2    |       T1      |       T2      |
            +---------------------------------------------------------------+
            ```
            If types T1 or T2 is not a scalar type (see <see cref="P:Spreads.Serialization.DataTypeHeader.IsScalar"/>)
            its slot is set to <see cref="F:Spreads.Serialization.TypeEnum.CompositeType"/>.
            </remarks>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Tuple2Byte">
             <summary>
             A tuple with two elements of different types prefixed with <see cref="T:System.Byte"/> tag.
             </summary>
             <remarks>
             Element types are stored in <see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS1"/>
             and <see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS2"/>.
             ```
             0                   1                   2                   3
             0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             | Version+Flags |     Tuple2    |       T1      |       T2      |
             +---------------------------------------------------------------+
            
             followed by
            
             [Optional Timestamp] | [Optional Schemas] | [Byte Tag] | [T1 Payload] | [T2 Payload]
             ```
             If types T1 or T2 are not a scalar type (see <see cref="P:Spreads.Serialization.DataTypeHeader.IsScalar"/>)
             their slot is set to <see cref="F:Spreads.Serialization.TypeEnum.CompositeType"/>.
             </remarks>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Tuple2Long">
            <summary>
            Same as <see cref="F:Spreads.Serialization.TypeEnum.Tuple2Byte"/> but with <see cref="T:System.Int64"/> prefix.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.KeyIndexValue">
            <summary>
            Row key type in TEOFS1, value type in TEOFS2. Always followed by <see cref="T:System.Int32"/> column index.
            Used for <see cref="!:Matrix&lt;T&gt;"/> and <see cref="!:Frame&lt;TRow,TCol&gt;"/> in-place value updates.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Array">
             <summary>
             A variable-length sequence of elements of the same type.
             </summary>
             <remarks>
             Element type stored in <see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS1"/>.
             ```
             0                   1                   2                   3
             0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             | Version+Flags |     Array     |       T       |      T1?      |
             +---------------------------------------------------------------+
             ```
             If type T is a scalar type (see <see cref="P:Spreads.Serialization.DataTypeHeader.IsScalar"/>) then
             T1 slot is empty. T1 could be a subtype of T if two slots is enough to
             describe the type T. If more than two slots are required to
             describe the type T then T slot is set to <see cref="F:Spreads.Serialization.TypeEnum.CompositeType"/>.
            
             </remarks>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.JaggedArray">
             <summary>
            
             </summary>
             <remarks>
             Element type stored in <see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS1"/>.
             Dimension is stored in <see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS2"/>.
            
             ```
             0                   1                   2                   3
             0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             | Version+Flags |  JaggedArray  |       T       |   Dimension   |
             +---------------------------------------------------------------+
             ```
             If element type is not a scalar type then T slot is set to <see cref="F:Spreads.Serialization.TypeEnum.CompositeType"/>.
            
             </remarks>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.ArrayOfTupleTN">
             <summary>
             A variable-length sequence of <see cref="F:Spreads.Serialization.TypeEnum.TupleTN"/> elements of the same type.
             </summary>
             <remarks>
             This type is common (e.g. it's a by-row part of a matrix) and we need to fuse <see cref="F:Spreads.Serialization.TypeEnum.Array"/> and <see cref="F:Spreads.Serialization.TypeEnum.TupleTN"/>
             first slot.
             The number of inner array elements is stored in <see cref="F:Spreads.Serialization.DataTypeHeader.TupleNCount"/> (<see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS1"/>).
             Element type is stored in <see cref="F:Spreads.Serialization.DataTypeHeader.TupleTNTeofs"/> (<see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS2"/>).
            
             ```
             0                   1                   2                   3
             0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             | Version+Flags | ArrayOfTupleTN|  TupleTNCount |       T       |
             +---------------------------------------------------------------+
             ```
             </remarks>
             <seealso cref="F:Spreads.Serialization.TypeEnum.TupleTN"/>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.NDArray">
             <summary>
            
             </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Table">
            <summary>
            Table is a frame with <see cref="T:System.String"/> row and column keys and <see cref="F:Spreads.Serialization.TypeEnum.Variant"/> data type.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Map">
             <summary>
             <see cref="F:Spreads.Serialization.TypeEnum.Array"/> of <see cref="F:Spreads.Serialization.TypeEnum.Tuple2"/> with unique keys.
             </summary>
             <remarks>
            
             Key type is stored in <see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS1"/>
             and value type is stored in <see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS2"/>.
            
             ```
             0                   1                   2                   3
             0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             | Version+Flags |      Map      |      TKey     |     TValue    |
             +---------------------------------------------------------------+
             ```
            
             </remarks>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Series">
             <summary>
             A series or two-array map (dictionary). A <see cref="F:Spreads.Serialization.TypeEnum.Tuple2"/> of two <see cref="F:Spreads.Serialization.TypeEnum.Array"/>s.
             </summary>
             <remarks>
             Note that when both types are blittable then <see cref="F:Spreads.Serialization.TypeEnum.Map"/> to/from <see cref="F:Spreads.Serialization.TypeEnum.Series"/>
             conversion could be done via shuffle/unshuffle very quickly.
            
             ```
             0                   1                   2                   3
             0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             | Version+Flags |     Series    |      TKey     |     TValue    |
             +---------------------------------------------------------------+
             ```
            
             </remarks>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Frame">
             <summary>
            
             </summary>
             <remarks>
            
             ```
             0                   1                   2                   3
             0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             | Version+Flags |     Frame     |    TRowKey    |   TColumnKey  |
             +---------------------------------------------------------------+
             ```
             </remarks>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.TupleN">
             <summary>
             A tuple with N elements of different types.
             </summary>
             <remarks>
             TupleN could have fixed size, e.g. (Timestamp,int,long,double).
             If all elements of such tuple are fixed-size scalars and their
             total size is no more than 256 bytes than <see cref="F:Spreads.Serialization.DataTypeHeader.TupleNFixedSize"/>
             field (the slot <see cref="F:Spreads.Serialization.DataTypeHeader.TEOFS2"/>) has the total size.
            
             ```
             0                   1                   2                   3
             0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             | Version+Flags |     TupleN    |  TupleNCount  |   FixedSize   |
             +---------------------------------------------------------------+
             ```
            
             </remarks>
             <seealso cref="F:Spreads.Serialization.TypeEnum.TupleTN"/>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.Variant">
            <summary>
            See <see cref="F:Spreads.Serialization.TypeEnum.Variant"/>. Has own <see cref="T:Spreads.Serialization.TypeEnum"/> values before payload. // TODO spec that
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.CompositeType">
            <summary>
            A type needs a generic context or stores a schema info somewhere in application context.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.UserType">
            <summary>
            A custom user type that could have a binary serializer or serialized as JSON.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnum.FixedSize">
             <summary>
             A virtual type enum used as return value of <see cref="P:Spreads.Serialization.TypeEnumOrFixedSize.TypeEnum"/> for blittable types (fixed-length type with fixed layout).
             </summary>
             <remarks>
            
             ```
             0                   1                   2                   3
             0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             | Version+Flags |   FixedSize   |         Size as short         |
             +---------------------------------------------------------------+
             ```
             </remarks>
        </member>
        <member name="M:Spreads.Serialization.TypeEnumHelper.GetSize(System.Byte)">
            <summary>
            Returns a positive size of top-level <see cref="T:Spreads.Serialization.TypeEnum"/>
            for scalars or -1 for composite types, which could still be
            fixed size. Use <see cref="F:Spreads.Serialization.DataTypeHeader.Size"/> property
            to get the size of a composite type.
            </summary>
            <param name="typeEnumValue"></param>
            <returns></returns>
        </member>
        <member name="T:Spreads.Serialization.ReflectionHelper">
            <summary>
            Note that performance here is the last concern and a static caching must be used after the first call.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnumInfo.FixedSize">
            <summary>
            Calculated recursively, not just pinned size/
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeEnumInfo.Composite">
            <summary>
            Sequence of TEOFS elements that are required to fully describe
            a type *in addition* to <see cref="F:Spreads.Serialization.TypeEnumInfo.Header"/>.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.TypeEnumHelper`1.CreateArrayInfo``1">
            <summary>
            Recursively get elemnt type info, fuse jagged arrays.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.TypeEnumHelper`1.GetTeofs">
            <summary>
            Top-level <see cref="T:Spreads.Serialization.TypeEnumOrFixedSize"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Spreads.Serialization.TypeEnumHelper`1.GetTypeEnum">
            <summary>
            Determines top-level shape of a type.
            TODO Decides priority of custom serializers over blittable representation
            </summary>
            <returns></returns>
        </member>
        <member name="T:Spreads.Serialization.TypeEnumOrFixedSize">
            <summary>
            Known type enum or size of unknown fixed-length type.
            Abbreviated as TEOFS in code and comments.
            </summary>
        </member>
        <member name="P:Spreads.Serialization.TypeEnumOrFixedSize.Size">
            <summary>
            Own size of a type.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeHelper`1.FixedSize">
            <summary>
            Returns a positive number for primitive type, well known fixed size types
            and pinnable structs with <see cref="T:Spreads.Serialization.BinarySerializationAttribute"/> and
            <see cref="P:Spreads.Serialization.BinarySerializationAttribute.BlittableSize"/> set to actual size.
            For other types returns -1.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeHelper`1.IsPinnable">
            <summary>
            True if T[] could be pinned in memory via GCHandle.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeHelper`1.IsValueType">
            <summary>
            CLR definition, we cache it here since ty.IsValueType is a virtual call
            </summary>
        </member>
        <member name="F:Spreads.Serialization.TypeHelper`1.IsIDelta">
            <summary>
            Implements <see cref="T:Spreads.Native.IDelta`1"/>
            </summary>
        </member>
        <member name="M:Spreads.Serialization.TypeHelper`1.GetPinnedSize">
            <summary>
            Distance between two elements of a pinned array.
            </summary>
        </member>
        <member name="T:Spreads.Serialization.VersionAndFlags">
             <summary>
             Version and flags
             </summary>
             <remarks>
             Format:
             ```
             0 1 2 3 4 5 6 7 8
             +-+-+-+-+-+-+-+-+
             |V|E|S|H|T|CMP|B|
             +---------------+
            
             B - Binary format (read as "Not JSON"). If not set then the payload is JSON,
             if set then payload is blittable or custom binary.
            
             CMP - Compression method:
                 00 - not compressed
                 01 - GZip
                 10 - Lz4
                 11 - Zstd
            
             V - Version. **Must be zero**. Otherwise there is a different header layout
             version that we hopefully will never have to implement. But if that sad
             day comes the existing data could be read with just a single if branch
             until it is totally converted to a new format (and yes, the format change
             must be so important that converting all data is justified, e.g.
             "Weissman score 5.2 vs 2.89" in some new compression codec or similar stuff :P ).
            
             The following flags are not used by BinarySerializer, which only uses
             three <see cref="P:Spreads.Serialization.VersionAndFlags.SerializationFormat"/> bits.
             These flags indicate that input payload has additional parts,
             such as 8 bytes timestamp, 16 bytes authentication tag,
             32 bytes hash and/or 64 bytes signature. BinarySerializer
             ignores these flags but its input data must be limited
             to the type described in <see cref="T:Spreads.Serialization.DataTypeHeader"/>,
             of which <see cref="T:Spreads.Serialization.VersionAndFlags"/> is the first byte.
            
             If all flags are set then the pipeline is:
             1. Decrypt. Will fail on tampered payload due to *AE* in AEAD.
             2. Deserialize payload. *AD* should have <see cref="T:Spreads.Serialization.DataTypeHeader"/>.
             3. Calculate hash and compare with the present one. If they do not match throw.
                This helps to find data corruption before encryption (which is optional).
             4. Verify signature from the hash. Public key is in application context.
             5. Timestamp is part of AD and must be valid if step 1 succeeds.
                Message is now verified for tampering in transit, corruption due to bad
                algorithm or storage
            
             T - Has timestamp.
            
             H - Has HashChain. Note that storing hash w/o signature is meaningless because it is easily computable.
             However hash chain has value on its own as much stronger than CRC32 linear checksum.
             In DataSpreads we need the linear property to be able to slice streams into blocks
             of arbitrary size but still be able to use signatures. E.g. 100 individual messages
             could be joined into one block and compressed but the signature of the last message
             is valid for the compressed block. We could just drop all intermediate signatures
             and hashes and have huge savings of space for small data messages.
            
             S - Has signature.
            
             E - Is encrypted.
            
             ```
             </remarks>
        </member>
        <member name="P:Spreads.Serialization.VersionAndFlags.IsBinary">
            <summary>
            Not JSON fallback but some custom layout (blittable or manual pack).
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.Formatters.EnumFormatter`1.#ctor(Spreads.Serialization.Utf8Json.JsonSerializeAction{`0},Spreads.Serialization.Utf8Json.JsonDeserializeFunc{`0})">
            <summary>
            If can not use dynamic code-generation environment and want to avoid boxing, you can set func manually.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.Internal.Emit.ExpressionUtility.GetMethodInfo``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Get MethodInfo from Expression for Static(with result) method.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.Internal.Emit.ExpressionUtility.GetMethodInfo(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            Get MethodInfo from Expression for Static(void) method.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.Internal.Emit.ExpressionUtility.GetMethodInfo``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Get MethodInfo from Expression for Instance(with result) method.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.Internal.Emit.ExpressionUtility.GetMethodInfo``1(System.Linq.Expressions.Expression{System.Action{``0}})">
            <summary>
            Get MethodInfo from Expression for Instance(void) method.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.Internal.Emit.ExpressionUtility.GetMethodInfo``2(System.Linq.Expressions.Expression{System.Action{``0,``1}})">
            <summary>
            Get MethodInfo from Expression for Instance(void) method.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.Internal.Emit.ExpressionUtility.GetMethodInfo``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
            <summary>
            Get MethodInfo from Expression for Instance(with result) method.
            </summary>
        </member>
        <member name="T:Spreads.Serialization.Utf8Json.Internal.Emit.ILGeneratorExtensions">
            <summary>
            Provides optimized generation code and helpers.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.Internal.Emit.ILGeneratorExtensions.EmitLdloc(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>
            Loads the local variable at a specific index onto the evaluation stack.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.Internal.Emit.ILGeneratorExtensions.EmitStloc(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>
            Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.Internal.Emit.ILGeneratorExtensions.EmitLdloca(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>
            Loads the address of the local variable at a specific index onto the evaluation statck.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.Internal.Emit.ILGeneratorExtensions.EmitLdc_I4(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>
            Pushes a supplied value of type int32 onto the evaluation stack as an int32.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.Internal.Emit.ILGeneratorExtensions.EmitPop(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>
            Helper for Pop op.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.Internal.Emit.ILGeneratorExtensions.EmitIncrementFor(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder,System.Action{System.Reflection.Emit.LocalBuilder})">
            <summary>for  var i = 0, i ..., i++ </summary>
        </member>
        <member name="T:Spreads.Serialization.Utf8Json.Internal.NumberConverter">
            <summary>
            zero-allocate itoa, dtoa, atoi, atod converters.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.Internal.NumberConverter.IsNumber(System.Byte)">
            <summary>
            0 ~ 9
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.Internal.NumberConverter.IsNumberRepresentation(System.Byte)">
            <summary>
            Is 0 ~ 9, '.', '+', '-'?
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.Internal.StringMutator.Original(System.String)">
            <summary>
            MyProperty -> MyProperty
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.Internal.StringMutator.ToCamelCase(System.String)">
            <summary>
            MyProperty -> myProperty
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.Internal.StringMutator.ToSnakeCase(System.String)">
            <summary>
            MyProperty -> my_property
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonReader.SkipWhiteSpace">
            <summary>
            Returns true if still in range after skipping ws
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonReader.ReadIsInArray(System.Int32@)">
            <summary>
            Convinient pattern of ReadIsBeginArrayWithVerify + while(!ReadIsEndArrayWithSkipValueSeparator)
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonReader.ReadIsInObject(System.Int32@)">
            <summary>
            Convinient pattern of ReadIsBeginObjectWithVerify + while(!ReadIsEndObjectWithSkipValueSeparator)
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonReader.ReadPropertyName">
            <summary>ReadString + ReadIsNameSeparatorWithVerify</summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonReader.ReadStringSegmentRaw">
            <summary>Get raw string-span(do not unescape)</summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonReader.ReadPropertyNameSegmentRaw">
            <summary>Get raw string-span(do not unescape) + ReadIsNameSeparatorWithVerify</summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonParsingException.GetUnderlyingByteArrayUnsafe">
            <summary>
            Underlying bytes is may be a pooling buffer, be careful to use it. If lost reference or can not handled byte[], return null.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonParsingException.GetUnderlyingStringUnsafe">
            <summary>
            Underlying bytes is may be a pooling buffer, be careful to use it. If lost reference or can not handled byte[], return null.
            </summary>
        </member>
        <member name="T:Spreads.Serialization.Utf8Json.JsonSerializer">
            <summary>
            High-Level API of Utf8Json.
            </summary>
        </member>
        <member name="P:Spreads.Serialization.Utf8Json.JsonSerializer.DefaultResolver">
            <summary>
            FormatterResolver that used resolver less overloads. If does not set it, used StandardResolver.Default.
            </summary>
        </member>
        <member name="P:Spreads.Serialization.Utf8Json.JsonSerializer.IsInitialized">
            <summary>
            Is resolver decided?
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.Serialize``1(``0)">
            <summary>
            Serialize to binary with default resolver.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.Serialize``1(``0,Spreads.Serialization.Utf8Json.IJsonFormatterResolver)">
            <summary>
            Serialize to binary with specified resolver.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.Serialize``1(System.IO.Stream,``0)">
            <summary>
            Serialize to stream.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.Serialize``1(System.IO.Stream,``0,Spreads.Serialization.Utf8Json.IJsonFormatterResolver)">
            <summary>
            Serialize to stream with specified resolver.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.SerializeAsync``1(System.IO.Stream,``0)">
            <summary>
            Serialize to stream(write async).
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.SerializeAsync``1(System.IO.Stream,``0,Spreads.Serialization.Utf8Json.IJsonFormatterResolver)">
            <summary>
            Serialize to stream(write async) with specified resolver.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.SerializeUnsafe``1(``0)">
            <summary>
            Serialize to binary. Get the raw memory pool byte[]. The result can not share across thread and can not hold, so use quickly.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.SerializeUnsafe``1(``0,Spreads.Serialization.Utf8Json.IJsonFormatterResolver)">
            <summary>
            Serialize to binary with specified resolver. Get the raw memory pool byte[]. The result can not share across thread and can not hold, so use quickly.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.ToJsonString``1(``0)">
            <summary>
            Serialize to JsonString.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.ToJsonString``1(``0,Spreads.Serialization.Utf8Json.IJsonFormatterResolver)">
            <summary>
            Serialize to JsonString with specified resolver.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.NonGeneric.Serialize(System.Object)">
            <summary>
            Serialize to binary with default resolver.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.NonGeneric.Serialize(System.Type,System.Object)">
            <summary>
            Serialize to binary with default resolver.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.NonGeneric.Serialize(System.Object,Spreads.Serialization.Utf8Json.IJsonFormatterResolver)">
            <summary>
            Serialize to binary with specified resolver.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.NonGeneric.Serialize(System.Type,System.Object,Spreads.Serialization.Utf8Json.IJsonFormatterResolver)">
            <summary>
            Serialize to binary with specified resolver.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.NonGeneric.Serialize(System.IO.Stream,System.Object)">
            <summary>
            Serialize to stream.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.NonGeneric.Serialize(System.Type,System.IO.Stream,System.Object)">
            <summary>
            Serialize to stream.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.NonGeneric.Serialize(System.IO.Stream,System.Object,Spreads.Serialization.Utf8Json.IJsonFormatterResolver)">
            <summary>
            Serialize to stream with specified resolver.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.NonGeneric.Serialize(System.Type,System.IO.Stream,System.Object,Spreads.Serialization.Utf8Json.IJsonFormatterResolver)">
            <summary>
            Serialize to stream with specified resolver.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.NonGeneric.SerializeAsync(System.IO.Stream,System.Object)">
            <summary>
            Serialize to stream.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.NonGeneric.SerializeAsync(System.Type,System.IO.Stream,System.Object)">
            <summary>
            Serialize to stream.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.NonGeneric.SerializeAsync(System.IO.Stream,System.Object,Spreads.Serialization.Utf8Json.IJsonFormatterResolver)">
            <summary>
            Serialize to stream with specified resolver.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.NonGeneric.SerializeAsync(System.Type,System.IO.Stream,System.Object,Spreads.Serialization.Utf8Json.IJsonFormatterResolver)">
            <summary>
            Serialize to stream with specified resolver.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.NonGeneric.SerializeUnsafe(System.Object)">
            <summary>
            Serialize to binary. Get the raw memory pool byte[]. The result can not share across thread and can not hold, so use quickly.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.NonGeneric.SerializeUnsafe(System.Type,System.Object)">
            <summary>
            Serialize to binary. Get the raw memory pool byte[]. The result can not share across thread and can not hold, so use quickly.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.NonGeneric.SerializeUnsafe(System.Object,Spreads.Serialization.Utf8Json.IJsonFormatterResolver)">
            <summary>
            Serialize to binary with specified resolver. Get the raw memory pool byte[]. The result can not share across thread and can not hold, so use quickly.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.NonGeneric.SerializeUnsafe(System.Type,System.Object,Spreads.Serialization.Utf8Json.IJsonFormatterResolver)">
            <summary>
            Serialize to binary with specified resolver. Get the raw memory pool byte[]. The result can not share across thread and can not hold, so use quickly.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.NonGeneric.ToJsonString(System.Object)">
            <summary>
            Serialize to JsonString.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.NonGeneric.ToJsonString(System.Type,System.Object)">
            <summary>
            Serialize to JsonString.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.NonGeneric.ToJsonString(System.Object,Spreads.Serialization.Utf8Json.IJsonFormatterResolver)">
            <summary>
            Serialize to JsonString with specified resolver.
            </summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonSerializer.NonGeneric.ToJsonString(System.Type,System.Object,Spreads.Serialization.Utf8Json.IJsonFormatterResolver)">
            <summary>
            Serialize to JsonString with specified resolver.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.JsonToken.BeginObject">
            <summary>{</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.JsonToken.EndObject">
            <summary>}</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.JsonToken.BeginArray">
            <summary>[</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.JsonToken.EndArray">
            <summary>]</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.JsonToken.Number">
            <summary>0~9, -</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.JsonToken.String">
            <summary>"</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.JsonToken.True">
            <summary>t</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.JsonToken.False">
            <summary>f</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.JsonToken.Null">
            <summary>n</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.JsonToken.ValueSeparator">
            <summary>,</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.JsonToken.NameSeparator">
            <summary>:</summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonWriter.WriteNameSeparator">
            <summary>:</summary>
        </member>
        <member name="M:Spreads.Serialization.Utf8Json.JsonWriter.WritePropertyName(System.String)">
            <summary>WriteString + WriteNameSeparator</summary>
        </member>
        <member name="T:Spreads.Serialization.Utf8Json.Resolvers.AttributeFormatterResolver">
            <summary>
            Get formatter from [JsonFormatter] attribute.
            </summary>
        </member>
        <member name="T:Spreads.Serialization.Utf8Json.Resolvers.DynamicObjectResolver">
            <summary>
            ObjectResolver by dynamic code generation.
            </summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.DynamicObjectResolver.Default">
            <summary>AllowPrivate:False, ExcludeNull:False, NameMutate:Original</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.DynamicObjectResolver.CamelCase">
            <summary>AllowPrivate:False, ExcludeNull:False, NameMutate:CamelCase</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.DynamicObjectResolver.SnakeCase">
            <summary>AllowPrivate:False, ExcludeNull:False, NameMutate:SnakeCase</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.DynamicObjectResolver.ExcludeNull">
            <summary>AllowPrivate:False, ExcludeNull:True,  NameMutate:Original</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.DynamicObjectResolver.ExcludeNullCamelCase">
            <summary>AllowPrivate:False, ExcludeNull:True,  NameMutate:CamelCase</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.DynamicObjectResolver.ExcludeNullSnakeCase">
            <summary>AllowPrivate:False, ExcludeNull:True,  NameMutate:SnakeCase</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.DynamicObjectResolver.AllowPrivate">
            <summary>AllowPrivate:True,  ExcludeNull:False, NameMutate:Original</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.DynamicObjectResolver.AllowPrivateCamelCase">
            <summary>AllowPrivate:True,  ExcludeNull:False, NameMutate:CamelCase</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.DynamicObjectResolver.AllowPrivateSnakeCase">
            <summary>AllowPrivate:True,  ExcludeNull:False, NameMutate:SnakeCase</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.DynamicObjectResolver.AllowPrivateExcludeNull">
            <summary>AllowPrivate:True,  ExcludeNull:True,  NameMutate:Original</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.DynamicObjectResolver.AllowPrivateExcludeNullCamelCase">
            <summary>AllowPrivate:True,  ExcludeNull:True,  NameMutate:CamelCase</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.DynamicObjectResolver.AllowPrivateExcludeNullSnakeCase">
            <summary>AllowPrivate:True,  ExcludeNull:True,  NameMutate:SnakeCase</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.EnumResolver.Default">
            <summary>Serialize as Name.</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.EnumResolver.UnderlyingValue">
            <summary>Serialize as Value.</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.StandardResolver.Default">
            <summary>AllowPrivate:False, ExcludeNull:False, NameMutate:Original</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.StandardResolver.CamelCase">
            <summary>AllowPrivate:False, ExcludeNull:False, NameMutate:CamelCase</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.StandardResolver.SnakeCase">
            <summary>AllowPrivate:False, ExcludeNull:False, NameMutate:SnakeCase</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.StandardResolver.ExcludeNull">
            <summary>AllowPrivate:False, ExcludeNull:True,  NameMutate:Original</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.StandardResolver.ExcludeNullCamelCase">
            <summary>AllowPrivate:False, ExcludeNull:True,  NameMutate:CamelCase</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.StandardResolver.ExcludeNullSnakeCase">
            <summary>AllowPrivate:False, ExcludeNull:True,  NameMutate:SnakeCase</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.StandardResolver.AllowPrivate">
            <summary>AllowPrivate:True,  ExcludeNull:False, NameMutate:Original</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.StandardResolver.AllowPrivateCamelCase">
            <summary>AllowPrivate:True,  ExcludeNull:False, NameMutate:CamelCase</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.StandardResolver.AllowPrivateSnakeCase">
            <summary>AllowPrivate:True,  ExcludeNull:False, NameMutate:SnakeCase</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.StandardResolver.AllowPrivateExcludeNull">
            <summary>AllowPrivate:True,  ExcludeNull:True,  NameMutate:Original</summary>
        </member>
        <member name="F:Spreads.Serialization.Utf8Json.Resolvers.StandardResolver.AllowPrivateExcludeNullCamelCase">
            <summary>AllowPrivate:True,  ExcludeNull:True,  NameMutate:CamelCase</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Spreads.Serialization.Utf8Json.Resolvers.StandardResolver.AllowPrivateExcludeNullSnakeCase" -->
        <member name="F:Spreads.AdditionalCorrectnessChecks.Enabled">
            <summary>
            A JIT-time constant that could be enabled via <see cref="P:Spreads.Settings.DoAdditionalCorrectnessChecks"/>
            in Release mode (default is false). It is always true in Debug mode.
            </summary>
            <remarks>
            Unless <see cref="P:Spreads.Settings.DoAdditionalCorrectnessChecks"/> is changed from default before this internal
            class is ever referenced from any code path it will have default
            value and this field will be JIT compile-time constant. If set to false, checks such as
            `if(AdditionalCorrectnessChecks.Enabled)` will be
            completely eliminated by JIT.
            </remarks>
        </member>
        <member name="T:Spreads.Settings">
            <summary>
            Global settings.
            </summary>
        </member>
        <member name="F:Spreads.Settings.LARGE_BUFFER_POOL_SCALE">
            <summary>
            Multiply pool buffer count by this scale factor when
            buffer size is equal to <see cref="F:Spreads.Settings.LARGE_BUFFER_LIMIT"/>,
            so that there are more most frequently used buffers pooled.
            </summary>
        </member>
        <member name="P:Spreads.Settings.DefaultSerializationFormat">
            <summary>
            Get or set default compression method: BinaryLz4 (default) or BinaryZstd).
            </summary>
        </member>
        <member name="P:Spreads.Settings.DoAdditionalCorrectnessChecks">
            <summary>
            Enable/disable additional correctness checks that could affect performance or exit the process with FailFast.
            This could only be set at application startup before accessing other Spreads types.
            By default this value is set to true and Spreads usually fails fast on any condition
            that could compromise calculation correctness or data integrity. If an application
            that uses Spreads runs correctly "long-enough" this setting could be set to false to measure
            the effect of the checks on performance. If the effect is not significant it is safer
            to keep this option as true if correctness of Spreads is more important than nanoseconds
            and fail fast is more acceptable scenario than incorrect calculations.
            </summary>
            <remarks>
            In Spreads, this setting is used for cases that does not reduce performance
            a lot, e.g. null or range checks in hot loops that take fixed number of
            CPU cycles, break inlining or similar fixed-time impact.
            It should not be used e.g. to allocate finalizable objects to detect leaks
            in buffer management and other cases that could generate a lot of garbage and
            induce GC latency. For the later cases `#if DEBUG` is used.
            </remarks>
        </member>
        <member name="P:Spreads.Settings.DoDetectBufferLeaks">
            <summary>
            When enabled buffers not returned to a pool will throw.
            Kills performance and produces a lot of garbage. Only
            for diagnostics.
            </summary>
        </member>
        <member name="P:Spreads.Settings.LZ4CompressionLevel">
            <summary>
            Default is 5.
            </summary>
        </member>
        <member name="P:Spreads.Settings.ZstdCompressionLevel">
            <summary>
            Default is 1. For many data types the default value
            increases IO throughput, i.e. time spent on both compression
            and writing smaller data is less than time spent on writing
            uncompressed data. Higher compression level only marginally
            improves compression ratio. Even Zstandard authors recommend
            using minimal compression level for most use cases.
            Please measure time and compression ratio with different
            compression levels before increasing the default level.
            </summary>
        </member>
        <member name="P:Spreads.Settings.ZlibCompressionLevel">
            <summary>
            Default is 3.
            </summary>
        </member>
        <member name="P:Spreads.Settings.EnableChaosMonkey">
            <summary>
            Set this property before accessing ChaosMonkey or types that use it.
            When false then this value is stored in static readonly field and is
            optimized away by JIT without any performance impact.
            </summary>
        </member>
        <member name="P:Spreads.Settings.CompressionStartFrom">
            <summary>
            Minimum serialized payload size to apply compression.
            The value is inclusive.
            </summary>
        </member>
        <member name="P:Spreads.Settings.DefensiveBinarySerializerWrite">
             <summary>
             If <see cref="!:BinarySerializer&lt;T&gt;.SizeOf(T,out Spreads.Buffers.RetainedMemory&lt;byte&gt;)"/> does not return a temp buffer
             then force using a temp buffer for destination of <see cref="M:Spreads.Serialization.BinarySerializer`1.Write(`0@,Spreads.Buffers.DirectBuffer)"/>
             method. This is slower but useful to ensure correct implementation of
             a custom <see cref="T:Spreads.Serialization.BinarySerializer`1"/>.
            
             <para>By default is set to <see cref="P:Spreads.Settings.DoAdditionalCorrectnessChecks"/></para>
            
             </summary>
        </member>
        <member name="F:Spreads.Settings.UseStructLayoutSizeAsBlittableSize">
            <summary>
            Set to true to use <see cref="F:System.Runtime.InteropServices.StructLayoutAttribute.Size"/> as <see cref="P:Spreads.Serialization.BinarySerializationAttribute.BlittableSize"/>.
            </summary>
        </member>
        <member name="F:Spreads.Settings.UseInterpolatedSearchForKnownTypes">
            <summary>
            This only affects known types for which interpolation search works correctly
            and is expected to be significantly faster. No reason to set it to false.
            </summary>
        </member>
        <member name="T:Spreads.Threading.AtomicCounter">
            <summary>
            Counts non-negative value and stores it in provided pointer in pinned/native memory.
            </summary>
        </member>
        <member name="F:Spreads.Threading.AtomicCounter.Pointer">
            <summary>
            Value in pointer:
            0 - not retained, could be taken from pool for temp usage with e.g. return in finally
            > 0 - number of retained calls
            -1 - disposed, either to object pool or GC
            less than -1 - ~(value) is index of the next free slot in the pool
            </summary>
        </member>
        <member name="M:Spreads.Threading.AtomicCounter.Decrement(System.Int32@)">
            <summary>
            Decrement a positive counter. Throws if counter is zero.
            </summary>
        </member>
        <member name="M:Spreads.Threading.AtomicCounter.IncrementIfRetained(System.Int32@)">
            <summary>
            Returns new count value if incremented or zero if the current count value is zero.
            </summary>
        </member>
        <member name="M:Spreads.Threading.AtomicCounter.DecrementIfOne(System.Int32@)">
            <summary>
            Returns zero if decremented the last reference or current count if it is more than one.
            Throws if current count is zero.
            </summary>
            <remarks>
            Throwing when current count is zero is correct because this call should be made
            when count reaches 1. A race with self is not possible with correct usage. E.g. if two users
            are holding refs then RC is 3, the first calling Decrement will have remaining = 2
            and should not call this method. This method protects from another thread incrementing
            the RC while the one that saw remaining at 1 is trying to dispose or cleanup. If this
            methods returns a positive number > 1 then a resource is being reused and dispose
            should be skipped.
            </remarks>
        </member>
        <member name="T:Spreads.Threading.AtomicCounterPool`1">
            <summary>
            Pool of `AtomicCounter`s backed by native memory. Avoid long-living pinned buffer in managed heap.
            </summary>
        </member>
        <member name="F:Spreads.Threading.AtomicCounterPool`1._pinnedSpan">
            <summary>
            Internal for tests only, do not use
            </summary>
        </member>
        <member name="M:Spreads.Threading.AtomicCounterPool`1.TryAcquireCounter(Spreads.Threading.AtomicCounter@)">
            <summary>
            Return a new AtomicCounter backed by some slot in the pool.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Spreads.Threading.ISpreadsThreadPoolWorkItem">
            <summary>Represents a work item that can be executed by the ThreadPool.</summary>
        </member>
        <member name="P:Spreads.Threading.LocalMulticast`1.Name">
            <summary>
            Instance name useful for debugging.
            </summary>
        </member>
        <member name="M:Spreads.Threading.LocalMulticast`1.StartReceive">
            <summary>
            Start additional receiver. A single receiver is started from the constructor.
            </summary>
        </member>
        <member name="T:Spreads.Threading.LocalMulticast`1.CachedEndPoint">
            <summary>
            Reduce GC by caching Create and Serialize methods.
            </summary>
        </member>
        <member name="T:Spreads.Threading.ManualResetValueTaskSourceCore`1">
            <summary>Provides the core logic for implementing a manual-reset <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource"/> or <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource`1"/>.</summary>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="F:Spreads.Threading.ManualResetValueTaskSourceCore`1._continuation">
            <summary>
            The callback to invoke when the operation completes if <see cref="M:Spreads.Threading.ManualResetValueTaskSourceCore`1.OnCompleted(System.Action{System.Object},System.Object,System.Int16,System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags)"/> was called before the operation completed,
            or <see cref="F:Spreads.Threading.ManualResetValueTaskSourceCoreShared.s_sentinel"/> if the operation completed before a callback was supplied,
            or null if a callback hasn't yet been provided and the operation hasn't yet completed.
            </summary>
        </member>
        <member name="F:Spreads.Threading.ManualResetValueTaskSourceCore`1._continuationState">
            <summary>State to pass to <see cref="F:Spreads.Threading.ManualResetValueTaskSourceCore`1._continuation"/>.</summary>
        </member>
        <member name="F:Spreads.Threading.ManualResetValueTaskSourceCore`1._executionContext">
            <summary><see cref="T:System.Threading.ExecutionContext"/> to flow to the callback, or null if no flowing is required.</summary>
        </member>
        <member name="F:Spreads.Threading.ManualResetValueTaskSourceCore`1._capturedContext">
            <summary>
            A "captured" <see cref="T:System.Threading.SynchronizationContext"/> or <see cref="T:System.Threading.Tasks.TaskScheduler"/> with which to invoke the callback,
            or null if no special context is required.
            </summary>
        </member>
        <member name="F:Spreads.Threading.ManualResetValueTaskSourceCore`1._completed">
            <summary>Whether the current operation has completed.</summary>
        </member>
        <member name="F:Spreads.Threading.ManualResetValueTaskSourceCore`1._result">
            <summary>The result with which the operation succeeded, or the default value if it hasn't yet completed or failed.</summary>
        </member>
        <member name="F:Spreads.Threading.ManualResetValueTaskSourceCore`1._error">
            <summary>The exception with which the operation failed, or null if it hasn't yet completed or completed successfully.</summary>
        </member>
        <member name="F:Spreads.Threading.ManualResetValueTaskSourceCore`1._version">
            <summary>The current version of this value, used to help prevent misuse.</summary>
        </member>
        <member name="P:Spreads.Threading.ManualResetValueTaskSourceCore`1.RunContinuationsAsynchronously">
            <summary>Gets or sets whether to force continuations to run asynchronously.</summary>
            <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>
        </member>
        <member name="M:Spreads.Threading.ManualResetValueTaskSourceCore`1.Reset">
            <summary>Resets to prepare for the next operation.</summary>
        </member>
        <member name="M:Spreads.Threading.ManualResetValueTaskSourceCore`1.SetResult(`0)">
            <summary>Completes with a successful result.</summary>
            <param name="result">The result.</param>
        </member>
        <member name="M:Spreads.Threading.ManualResetValueTaskSourceCore`1.SetException(System.Exception)">
            <summary>Completes with an error.</summary>
            <param name="error"></param>
        </member>
        <member name="P:Spreads.Threading.ManualResetValueTaskSourceCore`1.Version">
            <summary>Gets the operation version.</summary>
        </member>
        <member name="M:Spreads.Threading.ManualResetValueTaskSourceCore`1.GetStatus(System.Int16)">
            <summary>Gets the status of the operation.</summary>
            <param name="token">Opaque value that was provided to the <see cref="T:System.Threading.Tasks.ValueTask"/>'s constructor.</param>
        </member>
        <member name="M:Spreads.Threading.ManualResetValueTaskSourceCore`1.GetResult(System.Int16)">
            <summary>Gets the result of the operation.</summary>
            <param name="token">Opaque value that was provided to the <see cref="T:System.Threading.Tasks.ValueTask"/>'s constructor.</param>
        </member>
        <member name="M:Spreads.Threading.ManualResetValueTaskSourceCore`1.OnCompleted(System.Action{System.Object},System.Object,System.Int16,System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags)">
            <summary>Schedules the continuation action for this operation.</summary>
            <param name="continuation">The continuation to invoke when the operation has completed.</param>
            <param name="state">The state object to pass to <paramref name="continuation"/> when it's invoked.</param>
            <param name="token">Opaque value that was provided to the <see cref="T:System.Threading.Tasks.ValueTask"/>'s constructor.</param>
            <param name="flags">The flags describing the behavior of the continuation.</param>
        </member>
        <member name="M:Spreads.Threading.ManualResetValueTaskSourceCore`1.ValidateToken(System.Int16)">
            <summary>Ensures that the specified token matches the current version.</summary>
            <param name="token">The token supplied by <see cref="T:System.Threading.Tasks.ValueTask"/>.</param>
        </member>
        <member name="M:Spreads.Threading.ManualResetValueTaskSourceCore`1.SignalCompletion">
            <summary>Signals that the operation has completed.  Invoked after the result or error has been set.</summary>
        </member>
        <member name="M:Spreads.Threading.ManualResetValueTaskSourceCore`1.InvokeContinuation">
            <summary>
            Invokes the continuation with the appropriate captured context / scheduler.
            This assumes that if <see cref="F:Spreads.Threading.ManualResetValueTaskSourceCore`1._executionContext"/> is not null we're already
            running within that <see cref="T:System.Threading.ExecutionContext"/>.
            </summary>
        </member>
        <member name="T:Spreads.Threading.IWpidHelper">
            <summary>
            Helper methods for <see cref="T:Spreads.Threading.SharedSpinLock"/> and <see cref="T:Spreads.Threading.Wpid"/>.
            Think of this interface as a collection of delegates and not as an object.
            </summary>
        </member>
        <member name="P:Spreads.Threading.IWpidHelper.MyWpid">
            <summary>
            <see cref="T:Spreads.Threading.Wpid"/> of this helper.
            </summary>
        </member>
        <member name="M:Spreads.Threading.IWpidHelper.IsWpidAlive(Spreads.Threading.Wpid)">
            <summary>
            Both <see cref="P:Spreads.Threading.Wpid.Pid"/> and <see cref="P:Spreads.Threading.Wpid.InstanceId"/> must be alive.
            <see cref="P:Spreads.Threading.Wpid.Pid"/> is checked with <see cref="M:System.Diagnostics.Process.GetProcessById(System.Int32)"/>
            and <see cref="P:Spreads.Threading.Wpid.InstanceId"/> is checked according to some application logic.
            </summary>
            <remarks>
            It should not be possible that InstanceId is alive while Pid is not, while the same
            system process could have multiple logical instances. If Pid is dead then we could
            return false immediately. If Pid is alive but InstanceId is not then we should wait longer.
            Check should be something like:
            1. Return true if InstanceId heartbeat is less then a small limit. This should be a very fast check.
            2. Consult <see cref="M:System.Diagnostics.Process.GetProcessById(System.Int32)"/> to check if Pid part of <paramref name="wpid"/> is alive.
               Return false if not (additionally mark logical instance as dead to help other processes and speed up clean up).
            3. Repeat 1-2 up to some counter limit so that total time account for any realistic delay in heartbeat update,
               e.g. assume that heartbeat is updated by a lower-priority thread than other threads that are occupying 100% of CPU.
            </remarks>
        </member>
        <member name="M:Spreads.Threading.IWpidHelper.Suicide">
            <summary>
            Declare logical instance of this helper as dead.
            <see cref="M:Spreads.Threading.IWpidHelper.IsWpidAlive(Spreads.Threading.Wpid)"/> should always return <see langword="false" /> for <see cref="T:Spreads.Threading.Wpid"/> of this helper.
            </summary>
        </member>
        <member name="M:Spreads.Threading.IWpidHelper.OnForceUnlock(Spreads.Threading.Wpid)">
            <summary>
            Notify that <see cref="T:Spreads.Threading.SharedSpinLock"/> has detected dead lock holder and unlocked it.
            </summary>
            <param name="wpid"></param>
        </member>
        <member name="T:Spreads.Threading.Wpid">
            <summary>
            Wide process id: system process id + logical instance id.
            </summary>
        </member>
        <member name="F:Spreads.Threading.Wpid.PidMultiple">
            <summary>
            More than uint.MaxValue and keeps Pid human readable from raw value. Mul/Mod are never in the hot path so keep it simple.
            </summary>
        </member>
        <member name="F:Spreads.Threading.Wpid._value">
             <summary>
             We need long and Int32 InstanceId because it is persistent and unique among running processes.
             It could wrap around after int32.MaxValue process starts, or approximately a month if processes
             start every 1 millisecond (or 7 years if processes start every 100 milliseconds).
             Additionally one could have some logic to avoid creating Wpid for a live instance (e.g. <see cref="M:Spreads.Threading.IWpidHelper.IsWpidAlive(Spreads.Threading.Wpid)"/>).
            
             <para />
            
             This is very important for Docker without pid==host, where Pid==1 for all containers and the only way to separate processes in InstanceId.
             </summary>
        </member>
        <member name="T:Spreads.Threading.SharedSpinLock">
            <summary>
            TAS lock over (potentially) shared memory.
            </summary>
        </member>
        <member name="M:Spreads.Threading.SharedSpinLock.GetIsExclusiveLock(System.Int64@,Spreads.Threading.Wpid)">
            <summary>
            Wpid is holding a lock with priority, which is only possible when the lock is exclusive.
            Normally priority has a waiter that first reached a threshold spin number.
            </summary>
        </member>
        <member name="M:Spreads.Threading.SharedSpinLock.TryAcquireLock(System.Int64@,Spreads.Threading.Wpid,System.Int32,Spreads.Threading.IWpidHelper,System.Boolean)">
            <summary>
            Returns zero if acquired lock or Wpid of existing lock holder.
            </summary>
        </member>
        <member name="M:Spreads.Threading.SharedSpinLock.TryReleaseLock(System.Int64@,Spreads.Threading.Wpid,System.Boolean)">
            <summary>
            Returns zero if released lock.
            </summary>
        </member>
        <member name="T:Spreads.Threading.ThreadType">
            <summary>
            The type of threads to use - either foreground or background threads.
            </summary>
        </member>
        <member name="T:Spreads.Threading.ThreadPoolSettings">
            <summary>
            Provides settings for a dedicated thread pool
            </summary>
        </member>
        <member name="F:Spreads.Threading.ThreadPoolSettings.DefaultThreadType">
            <summary>
            Background threads are the default thread type
            </summary>
        </member>
        <member name="P:Spreads.Threading.ThreadPoolSettings.NumThreads">
            <summary>
            The total number of threads to run in this thread pool.
            </summary>
        </member>
        <member name="P:Spreads.Threading.ThreadPoolSettings.ThreadType">
            <summary>
            The type of threads to run in this thread pool.
            </summary>
        </member>
        <member name="P:Spreads.Threading.ThreadPoolSettings.ApartmentState">
            <summary>
            Apartment state for threads to run in this thread pool
            </summary>
        </member>
        <member name="P:Spreads.Threading.ThreadPoolSettings.ThreadMaxStackSize">
            <summary>
            Gets the thread stack size, 0 represents the default stack size.
            </summary>
        </member>
        <member name="T:Spreads.Threading.SpreadsThreadPool">
            <summary>
            Non-allocating thread pool.
            </summary>
            <remarks>
            When using <see cref="P:Spreads.Threading.SpreadsThreadPool.Default"/> pool, it polyfills <see cref="!:ThreadPool.UnsafeQueueUserWorkItem(IThreadPoolWorkItem, bool)"/>
            method for .NET Standard using <see cref="T:Spreads.Threading.ISpreadsThreadPoolWorkItem"/> and uses
            <see cref="T:System.Threading.ThreadPool"/> for .NET Core 3 and above.
            <para/>
            When using non-<see cref="P:Spreads.Threading.SpreadsThreadPool.Default"/> pools, a custom implementation
            with <see cref="T:Spreads.Threading.ThreadPoolSettings"/> is always used.
            </remarks>
        </member>
        <member name="P:Spreads.Threading.SpreadsThreadPool.Background">
            <summary>
            A thread pool for lower priority tasks. By default
            it is the same pool as <see cref="P:Spreads.Threading.SpreadsThreadPool.Default"/>.
            </summary>
            <remarks>
            Could be set to a custom thread pool with lower thread priority,
            which might improve performance of the main thread pool.
            But keep in mind that tasks such as returning unused
            objects/buffers to an object/buffer pool could affect
            main threads performance (empty buffers could cause allocations).
            Instead of using lower thread priority a small number of threads
            in the background pool could be a better option.
            </remarks>
        </member>
        <member name="T:Spreads.Threading.SpreadsThreadPoolTaskScheduler">
            <summary>
            TaskScheduler for working with a <see cref="T:Spreads.Threading.SpreadsThreadPool"/> instance
            </summary>
        </member>
        <member name="F:Spreads.Threading.SpreadsThreadPoolTaskScheduler._parallelWorkers">
            <summary>
            Number of tasks currently running
            </summary>
        </member>
        <member name="P:Spreads.Threading.SpreadsThreadPoolTaskScheduler.MaximumConcurrencyLevel">
            <summary>
            Level of concurrency is directly equal to the number of threads
            in the <see cref="T:Spreads.Threading.SpreadsThreadPool"/>.
            </summary>
        </member>
        <member name="T:Spreads.Threading.TimeService">
            <summary>
            A time service that updates time in background and increments time by one nanosecond on every read, thus guaranteeing unique increasing time sequence.
            Could work with shared memory so that multiple processes see the same time.
            Supports high-precision mode when a dedicated thread polls time in a hot loop.
            </summary>
        </member>
        <member name="P:Spreads.Threading.TimeService.Default">
            <summary>
            Default instance that uses in-process
            </summary>
        </member>
        <member name="P:Spreads.Threading.TimeService.Now">
            <summary>
            A shortcut to <see cref="P:Spreads.Threading.TimeService.CurrentTime"/> value of <see cref="P:Spreads.Threading.TimeService.Default"/> default time service.
            </summary>
        </member>
        <member name="M:Spreads.Threading.TimeService.#ctor">
            <summary>
            Creates a new time service with update interval of 1 millisecond.
            </summary>
        </member>
        <member name="M:Spreads.Threading.TimeService.#ctor(System.IntPtr,System.Int32)">
            <summary>
            Creates a new time service.
            </summary>
            <param name="ptr">Memory location to store time.</param>
            <param name="intervalMilliseconds">Background update interval.</param>
        </member>
        <member name="M:Spreads.Threading.TimeService.StartSpinUpdate(System.Threading.CancellationToken,System.Threading.ThreadPriority,System.Int32)">
             <summary>
             Dedicate a thread to update time in a hot loop. Modern desktops even with Window OS
             could provide near microsecond time precision via <see cref="P:System.DateTime.UtcNow"/>, but
             the call is rather expensive. A dedicated thread could do this call and other threads
             just read the updated value and increment it by 1 nanosecond on every read.
            
             <para />
            
             By default thread priority is set to <see cref="F:System.Threading.ThreadPriority.Normal"/>. Setting this lower does
             not make a lot of sense, instead you could just use TimeService with default updates based on a timer.
             Low-priority thread will often be preempted by other threads and time precision will be bad.
             To lessen CPU consumption you could provide a positive <paramref name="spinCount"/>.
             On i7-8700 a value between 100-200 gives better precision. This is probably due to the expensive call
             to DateTime.UtcNow that takes just less than 1/2 of the system timer precision.
             Keep it at default unless measured a better precision with a different value.
             </summary>
             <param name="ct"><see cref="P:System.Threading.CancellationToken.CanBeCanceled"/> must be true, i.e. default one will not work.</param>
             <param name="priority">Thread priority. .</param>
             <param name="spinCount">Number of times to call <see cref="M:System.Threading.Thread.SpinWait(System.Int32)"/> after each time update.</param>
        </member>
        <member name="T:Spreads.Threading.UnfairSemaphore">
             <summary>
                 This class has been translated from:
             https://github.com/dotnet/coreclr/blob/97433b9d153843492008652ff6b7c3bf4d9ff31c/src/vm/win32threadpool.h#L124
            
             UnfairSemaphore is a more scalable semaphore than Semaphore.It prefers to release threads that have more recently begun waiting,
             to preserve locality.Additionally, very recently-waiting threads can be released without an addition kernel transition to unblock
             them, which reduces latency.
            
             UnfairSemaphore is only appropriate in scenarios where the order of unblocking threads is not important, and where threads frequently
             need to be woken.
             </summary>
        </member>
        <member name="T:Spreads.Utils.CanBeNullAttribute">
             <summary>
             Indicates that the value of the marked element could be <c>null</c> sometimes,
             so the check for <c>null</c> is necessary before its usage.
             </summary>
             <example><code>
             [CanBeNull] object Test() => null;
            
             void UseTest() {
               var p = Test();
               var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
             }
             </code></example>
        </member>
        <member name="T:Spreads.Utils.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>.
            </summary>
            <example><code>
            [NotNull] object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:Spreads.Utils.ItemNotNullAttribute">
            <summary>
            Can be appplied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can never be null.
            </summary>
        </member>
        <member name="T:Spreads.Utils.ItemCanBeNullAttribute">
            <summary>
            Can be appplied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can be null.
            </summary>
        </member>
        <member name="T:Spreads.Utils.StringFormatMethodAttribute">
             <summary>
             Indicates that the marked method builds string by format pattern and (optional) arguments.
             Parameter, which contains format string, should be given in constructor. The format string
             should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form.
             </summary>
             <example><code>
             [StringFormatMethod("message")]
             void ShowError(string message, params object[] args) { /* do something */ }
            
             void Foo() {
               ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
             }
             </code></example>
        </member>
        <member name="M:Spreads.Utils.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:Spreads.Utils.ValueProviderAttribute">
            <summary>
            For a parameter that is expected to be one of the limited set of values.
            Specify fields of which type should be used as values for this parameter.
            </summary>
        </member>
        <member name="T:Spreads.Utils.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException"/>.
            </summary>
            <example><code>
            void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:Spreads.Utils.NotifyPropertyChangedInvocatorAttribute">
             <summary>
             Indicates that the method is contained in a type that implements
             <c>System.ComponentModel.INotifyPropertyChanged</c> interface and this method
             is used to notify that some property value changed.
             </summary>
             <remarks>
             The method should be non-static and conform to one of the supported signatures:
             <list>
             <item><c>NotifyChanged(string)</c></item>
             <item><c>NotifyChanged(params string[])</c></item>
             <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
             <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
             <item><c>SetProperty{T}(ref T, T, string)</c></item>
             </list>
             </remarks>
             <example><code>
             public class Foo : INotifyPropertyChanged {
               public event PropertyChangedEventHandler PropertyChanged;
            
               [NotifyPropertyChangedInvocator]
               protected virtual void NotifyChanged(string propertyName) { ... }
            
               string _name;
            
               public string Name {
                 get { return _name; }
                 set { _name = value; NotifyChanged("LastName"); /* Warning */ }
               }
             }
             </code>
             Examples of generated notifications:
             <list>
             <item><c>NotifyChanged("Property")</c></item>
             <item><c>NotifyChanged(() =&gt; Property)</c></item>
             <item><c>NotifyChanged((VM x) =&gt; x.Property)</c></item>
             <item><c>SetProperty(ref myField, value, "Property")</c></item>
             </list>
             </example>
        </member>
        <member name="T:Spreads.Utils.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output.
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If method has single input parameter, it's name could be omitted.<br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same) for method output
            means that the methos doesn't return normally (throws or terminates the process).<br/>
            Value <c>canbenull</c> is only applicable for output parameters.<br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row, or use single attribute
            with rows separated by semicolon. There is no notion of order rows, all rows are checked
            for applicability and applied per each program state tracked by R# analysis.<br/>
            </syntax>
            <examples><list>
            <item><code>
            [ContractAnnotation("=&gt; halt")]
            public void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // regular assertion method
            </code></item>
            <item><code>
            [ContractAnnotation("s:null =&gt; true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null,
            // and not null if the parameter is not null
            [ContractAnnotation("null =&gt; null; notnull =&gt; notnull")]
            public object Transform(object data)
            </code></item>
            <item><code>
            [ContractAnnotation("=&gt; true, result: notnull; =&gt; false, result: null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:Spreads.Utils.LocalizationRequiredAttribute">
            <summary>
            Indicates that marked element should be localized or not.
            </summary>
            <example><code>
            [LocalizationRequiredAttribute(true)]
            class Foo {
              string str = "my string"; // Warning: Localizable string
            }
            </code></example>
        </member>
        <member name="T:Spreads.Utils.CannotApplyEqualityOperatorAttribute">
             <summary>
             Indicates that the value of the marked type (or its derivatives)
             cannot be compared using '==' or '!=' operators and <c>Equals()</c>
             should be used instead. However, using '==' or '!=' for comparison
             with <c>null</c> is always permitted.
             </summary>
             <example><code>
             [CannotApplyEqualityOperator]
             class NoEquality { }
            
             class UsesNoEquality {
               void Test() {
                 var ca1 = new NoEquality();
                 var ca2 = new NoEquality();
                 if (ca1 != null) { // OK
                   bool condition = ca1 == ca2; // Warning
                 }
               }
             }
             </code></example>
        </member>
        <member name="T:Spreads.Utils.BaseTypeRequiredAttribute">
             <summary>
             When applied to a target attribute, specifies a requirement for any type marked
             with the target attribute to implement or inherit specific type or types.
             </summary>
             <example><code>
             [BaseTypeRequired(typeof(IComponent)] // Specify requirement
             class ComponentAttribute : Attribute { }
            
             [Component] // ComponentAttribute requires implementing IComponent interface
             class MyComponent : IComponent { }
             </code></example>
        </member>
        <member name="T:Spreads.Utils.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly (e.g. via reflection, in external library),
            so this symbol will not be marked as unused (as well as by other usage inspections).
            </summary>
        </member>
        <member name="T:Spreads.Utils.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper to not mark symbols marked with such attributes
            as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="F:Spreads.Utils.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used.</summary>
        </member>
        <member name="F:Spreads.Utils.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member.</summary>
        </member>
        <member name="F:Spreads.Utils.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:Spreads.Utils.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type.</summary>
        </member>
        <member name="T:Spreads.Utils.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered used implicitly when marked
            with <see cref="T:Spreads.Utils.MeansImplicitUseAttribute"/> or <see cref="T:Spreads.Utils.UsedImplicitlyAttribute"/>.
            </summary>
        </member>
        <member name="F:Spreads.Utils.ImplicitUseTargetFlags.Members">
            <summary>Members of entity marked with attribute are considered used.</summary>
        </member>
        <member name="F:Spreads.Utils.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with attribute and all its members considered used.</summary>
        </member>
        <member name="T:Spreads.Utils.PublicAPIAttribute">
            <summary>
            This attribute is intended to mark publicly available API
            which should not be removed and so is treated as used.
            </summary>
        </member>
        <member name="T:Spreads.Utils.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled when the invoked method is on stack.
            If the parameter is a delegate, indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated while the method is executed.
            </summary>
        </member>
        <member name="T:Spreads.Utils.PureAttribute">
             <summary>
             Indicates that a method does not make any observable state changes.
             The same as <c>System.Diagnostics.Contracts.PureAttribute</c>.
             </summary>
             <example><code>
             [Pure] int Multiply(int x, int y) => x * y;
            
             void M() {
               Multiply(123, 42); // Waring: Return value of pure method is not used
             }
             </code></example>
        </member>
        <member name="T:Spreads.Utils.MustUseReturnValueAttribute">
            <summary>
            Indicates that the return value of method invocation must be used.
            </summary>
        </member>
        <member name="T:Spreads.Utils.ProvidesContextAttribute">
             <summary>
             Indicates the type member or parameter of some type, that should be used instead of all other ways
             to get the value that type. This annotation is useful when you have some "context" value evaluated
             and stored somewhere, meaning that all other ways to get this value must be consolidated with existing one.
             </summary>
             <example><code>
             class Foo {
               [ProvidesContext] IBarService _barService = ...;
            
               void ProcessNode(INode node) {
                 DoSomething(node, node.GetGlobalServices().Bar);
                 //              ^ Warning: use value of '_barService' field
               }
             }
             </code></example>
        </member>
        <member name="T:Spreads.Utils.PathReferenceAttribute">
            <summary>
            Indicates that a parameter is a path to a file or a folder within a web project.
            Path can be relative or absolute, starting from web root (~).
            </summary>
        </member>
        <member name="T:Spreads.Utils.SourceTemplateAttribute">
            <summary>
            An extension method marked with this attribute is processed by ReSharper code completion
            as a 'Source Template'. When extension method is completed over some expression, it's source code
            is automatically expanded like a template at call site.
            </summary>
            <remarks>
            Template method body can contain valid source code and/or special comments starting with '$'.
            Text inside these comments is added as source code when the template is applied. Template parameters
            can be used either as additional method parameters or as identifiers wrapped in two '$' signs.
            Use the <see cref="T:Spreads.Utils.MacroAttribute"/> attribute to specify macros for parameters.
            </remarks>
            <example>
            In this example, the 'forEach' method is a source template available over all values
            of enumerable types, producing ordinary C# 'foreach' statement and placing caret inside block:
            <code>
            [SourceTemplate]
            public static void forEach&lt;T&gt;(this IEnumerable&lt;T&gt; xs) {
              foreach (var x in xs) {
                 //$ $END$
              }
            }
            </code>
            </example>
        </member>
        <member name="T:Spreads.Utils.MacroAttribute">
            <summary>
            Allows specifying a macro for a parameter of a <see cref="T:Spreads.Utils.SourceTemplateAttribute">source template</see>.
            </summary>
            <remarks>
            You can apply the attribute on the whole method or on any of its additional parameters. The macro expression
            is defined in the <see cref="P:Spreads.Utils.MacroAttribute.Expression"/> property. When applied on a method, the target
            template parameter is defined in the <see cref="P:Spreads.Utils.MacroAttribute.Target"/> property. To apply the macro silently
            for the parameter, set the <see cref="P:Spreads.Utils.MacroAttribute.Editable"/> property value = -1.
            </remarks>
            <example>
            Applying the attribute on a source template method:
            <code>
            [SourceTemplate, Macro(Target = "item", Expression = "suggestVariableName()")]
            public static void forEach&lt;T&gt;(this IEnumerable&lt;T&gt; collection) {
              foreach (var item in collection) {
                //$ $END$
              }
            }
            </code>
            Applying the attribute on a template method parameter:
            <code>
            [SourceTemplate]
            public static void something(this Entity x, [Macro(Expression = "guid()", Editable = -1)] string newguid) {
              /*$ var $x$Id = "$newguid$" + x.ToString();
              x.DoSomething($x$Id); */
            }
            </code>
            </example>
        </member>
        <member name="P:Spreads.Utils.MacroAttribute.Expression">
            <summary>
            Allows specifying a macro that will be executed for a <see cref="T:Spreads.Utils.SourceTemplateAttribute">source template</see>
            parameter when the template is expanded.
            </summary>
        </member>
        <member name="P:Spreads.Utils.MacroAttribute.Editable">
            <summary>
            Allows specifying which occurrence of the target parameter becomes editable when the template is deployed.
            </summary>
            <remarks>
            If the target parameter is used several times in the template, only one occurrence becomes editable;
            other occurrences are changed synchronously. To specify the zero-based index of the editable occurrence,
            use values >= 0. To make the parameter non-editable when the template is expanded, use -1.
            </remarks>>
        </member>
        <member name="P:Spreads.Utils.MacroAttribute.Target">
            <summary>
            Identifies the target parameter of a <see cref="T:Spreads.Utils.SourceTemplateAttribute">source template</see> if the
            <see cref="T:Spreads.Utils.MacroAttribute"/> is applied on a template method.
            </summary>
        </member>
        <member name="T:Spreads.Utils.AspMvcActionAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC action. If applied to a method, the MVC action name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:Spreads.Utils.AspMvcAreaAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC area.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:Spreads.Utils.AspMvcControllerAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is
            an MVC controller. If applied to a method, the MVC controller name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String, String)</c>.
            </summary>
        </member>
        <member name="T:Spreads.Utils.AspMvcMasterAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC Master. Use this attribute
            for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, String)</c>.
            </summary>
        </member>
        <member name="T:Spreads.Utils.AspMvcModelTypeAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC model type. Use this attribute
            for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, Object)</c>.
            </summary>
        </member>
        <member name="T:Spreads.Utils.AspMvcPartialViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is an MVC
            partial view. If applied to a method, the MVC partial view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.RenderPartialExtensions.RenderPartial(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:Spreads.Utils.AspMvcSuppressViewErrorAttribute">
            <summary>
            ASP.NET MVC attribute. Allows disabling inspections for MVC views within a class or a method.
            </summary>
        </member>
        <member name="T:Spreads.Utils.AspMvcDisplayTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC display template.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.DisplayExtensions.DisplayForModel(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:Spreads.Utils.AspMvcEditorTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC editor template.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.EditorExtensions.EditorForModel(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:Spreads.Utils.AspMvcTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC template.
            Use this attribute for custom wrappers similar to
            <c>System.ComponentModel.DataAnnotations.UIHintAttribute(System.String)</c>.
            </summary>
        </member>
        <member name="T:Spreads.Utils.AspMvcViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component. If applied to a method, the MVC view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(Object)</c>.
            </summary>
        </member>
        <member name="T:Spreads.Utils.AspMvcViewComponentAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component name.
            </summary>
        </member>
        <member name="T:Spreads.Utils.AspMvcViewComponentViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component view. If applied to a method, the MVC view component view name is default.
            </summary>
        </member>
        <member name="T:Spreads.Utils.AspMvcActionSelectorAttribute">
            <summary>
            ASP.NET MVC attribute. When applied to a parameter of an attribute,
            indicates that this parameter is an MVC action name.
            </summary>
            <example><code>
            [ActionName("Foo")]
            public ActionResult Login(string returnUrl) {
              ViewBag.ReturnUrl = Url.Action("Foo"); // OK
              return RedirectToAction("Bar"); // Error: Cannot resolve action
            }
            </code></example>
        </member>
        <member name="T:Spreads.Utils.RazorSectionAttribute">
            <summary>
            Razor attribute. Indicates that a parameter or a method is a Razor section.
            Use this attribute for custom wrappers similar to
            <c>System.Web.WebPages.WebPageBase.RenderSection(String)</c>.
            </summary>
        </member>
        <member name="T:Spreads.Utils.CollectionAccessAttribute">
            <summary>
            Indicates how method, constructor invocation or property access
            over collection type affects content of the collection.
            </summary>
        </member>
        <member name="F:Spreads.Utils.CollectionAccessType.None">
            <summary>Method does not use or modify content of the collection.</summary>
        </member>
        <member name="F:Spreads.Utils.CollectionAccessType.Read">
            <summary>Method only reads content of the collection but does not modify it.</summary>
        </member>
        <member name="F:Spreads.Utils.CollectionAccessType.ModifyExistingContent">
            <summary>Method can change content of the collection but does not add new elements.</summary>
        </member>
        <member name="F:Spreads.Utils.CollectionAccessType.UpdatedContent">
            <summary>Method can add new elements to the collection.</summary>
        </member>
        <member name="T:Spreads.Utils.AssertionMethodAttribute">
            <summary>
            Indicates that the marked method is assertion method, i.e. it halts control flow if
            one of the conditions is satisfied. To set the condition, mark one of the parameters with
            <see cref="T:Spreads.Utils.AssertionConditionAttribute"/> attribute.
            </summary>
        </member>
        <member name="T:Spreads.Utils.AssertionConditionAttribute">
            <summary>
            Indicates the condition parameter of the assertion method. The method itself should be
            marked by <see cref="T:Spreads.Utils.AssertionMethodAttribute"/> attribute. The mandatory argument of
            the attribute is the assertion type.
            </summary>
        </member>
        <member name="T:Spreads.Utils.AssertionConditionType">
            <summary>
            Specifies assertion type. If the assertion method argument satisfies the condition,
            then the execution continues. Otherwise, execution is assumed to be halted.
            </summary>
        </member>
        <member name="F:Spreads.Utils.AssertionConditionType.IS_TRUE">
            <summary>Marked parameter should be evaluated to true.</summary>
        </member>
        <member name="F:Spreads.Utils.AssertionConditionType.IS_FALSE">
            <summary>Marked parameter should be evaluated to false.</summary>
        </member>
        <member name="F:Spreads.Utils.AssertionConditionType.IS_NULL">
            <summary>Marked parameter should be evaluated to null value.</summary>
        </member>
        <member name="F:Spreads.Utils.AssertionConditionType.IS_NOT_NULL">
            <summary>Marked parameter should be evaluated to not null value.</summary>
        </member>
        <member name="T:Spreads.Utils.TerminatesProgramAttribute">
            <summary>
            Indicates that the marked method unconditionally terminates control flow execution.
            For example, it could unconditionally throw exception.
            </summary>
        </member>
        <member name="T:Spreads.Utils.LinqTunnelAttribute">
            <summary>
            Indicates that method is pure LINQ method, with postponed enumeration (like Enumerable.Select,
            .Where). This annotation allows inference of [InstantHandle] annotation for parameters
            of delegate type by analyzing LINQ method chains.
            </summary>
        </member>
        <member name="T:Spreads.Utils.NoEnumerationAttribute">
            <summary>
            Indicates that IEnumerable, passed as parameter, is not enumerated.
            </summary>
        </member>
        <member name="T:Spreads.Utils.RegexPatternAttribute">
            <summary>
            Indicates that parameter is regular expression pattern.
            </summary>
        </member>
        <member name="T:Spreads.Utils.NoReorderAttribute">
            <summary>
            Prevents the Member Reordering feature from tossing members of the marked class.
            </summary>
            <remarks>
            The attribute must be mentioned in your member reordering patterns
            </remarks>
        </member>
        <member name="T:Spreads.Utils.XamlItemsControlAttribute">
            <summary>
            XAML attribute. Indicates the type that has <c>ItemsSource</c> property and should be treated
            as <c>ItemsControl</c>-derived type, to enable inner items <c>DataContext</c> type resolve.
            </summary>
        </member>
        <member name="T:Spreads.Utils.XamlItemBindingOfItemsControlAttribute">
            <summary>
            XAML attribute. Indicates the property of some <c>BindingBase</c>-derived type, that
            is used to bind some item of <c>ItemsControl</c>-derived type. This annotation will
            enable the <c>DataContext</c> type resolve for XAML bindings for such properties.
            </summary>
            <remarks>
            Property should have the tree ancestor of the <c>ItemsControl</c> type or
            marked with the <see cref="T:Spreads.Utils.XamlItemsControlAttribute"/> attribute.
            </remarks>
        </member>
        <member name="T:Spreads.Utils.Benchmark">
            <summary>
            A utility to benchmark code snippets inside a using block.
            </summary>
        </member>
        <member name="P:Spreads.Utils.Benchmark.ForceSilence">
            <summary>
            Disable console output regardless of individual <see cref="M:Spreads.Utils.Benchmark.Run(System.String,System.Int64,System.Boolean)"/> method parameters.
            </summary>
        </member>
        <member name="M:Spreads.Utils.Benchmark.Run(System.String,System.Int64,System.Boolean)">
            <summary>
            Returns an <see cref="T:System.IDisposable"/> structure that starts benchmarking and stops it when its Dispose method is called.
            Prints benchmark results on disposal unless the silent parameter is not set to true.
            </summary>
            <param name="caseName">Benchmark case.</param>
            <param name="innerLoopCount">Number of iterations to calculate performance.</param>
            <param name="silent">True to mute console output during disposal.</param>
            <returns>A disposable structure that measures time and memory allocations until disposed.</returns>
        </member>
        <member name="M:Spreads.Utils.Benchmark.Dump(System.String,System.String,System.String)">
            <summary>
            Print a table with average benchmark results for all cases.
            </summary>
            <param name="summary"></param>
            <param name="caller">A description of the benchmark that is printed above the table.</param>
            <param name="unit">Overwrite default MOPS unit of measure</param>
        </member>
        <member name="T:Spreads.Utils.Benchmark.Stat">
            <summary>
            Benchmark run statistics.
            </summary>
        </member>
        <member name="M:Spreads.Utils.Benchmark.Stat.Dispose">
            <inheritdoc />
        </member>
        <member name="P:Spreads.Utils.Benchmark.Stat.MOPS">
            <summary>
            Million operations per second.
            </summary>
        </member>
        <member name="M:Spreads.Utils.Benchmark.Stat.ToString">
            <inheritdoc />
        </member>
        <member name="T:Spreads.Utils.BitUtil">
            <summary>
            Miscellaneous useful functions for dealing with low level bits and bytes.
            </summary>
        </member>
        <member name="F:Spreads.Utils.BitUtil.SIZE_OF_BYTE">
            <summary>
            Size of a byte in bytes
            </summary>
        </member>
        <member name="F:Spreads.Utils.BitUtil.SIZE_OF_BOOLEAN">
            <summary>
            Size of a boolean in bytes
            </summary>
        </member>
        <member name="F:Spreads.Utils.BitUtil.SIZE_OF_CHAR">
            <summary>
            Size of a char in bytes
            </summary>
        </member>
        <member name="F:Spreads.Utils.BitUtil.SIZE_OF_SHORT">
            <summary>
            Size of a short in bytes
            </summary>
        </member>
        <member name="F:Spreads.Utils.BitUtil.SIZE_OF_INT">
            <summary>
            Size of an int in bytes
            </summary>
        </member>
        <member name="F:Spreads.Utils.BitUtil.SIZE_OF_FLOAT">
            <summary>
            Size of a a float in bytes
            </summary>
        </member>
        <member name="F:Spreads.Utils.BitUtil.SIZE_OF_LONG">
            <summary>
            Size of a long in bytes
            </summary>
        </member>
        <member name="F:Spreads.Utils.BitUtil.SIZE_OF_DOUBLE">
            <summary>
            Size of a double in bytes
            </summary>
        </member>
        <member name="F:Spreads.Utils.BitUtil.CACHE_LINE_LENGTH">
            <summary>
            Length of the data blocks used by the CPU cache sub-system in bytes.
            </summary>
        </member>
        <member name="M:Spreads.Utils.BitUtil.FindNextPositivePowerOfTwo(System.Int32)">
             <summary>
             Fast method of finding the next power of 2 greater than or equal to the supplied value.
            
             If the value is &lt;= 0 then 1 will be returned.
            
             This method is not suitable for <seealso cref="F:System.Int32.MinValue"/> or numbers greater than 2^30.
             </summary>
             <param name="value"> from which to search for next power of 2 </param>
             <returns> The next power of 2 or the value itself if it is a power of 2 </returns>
        </member>
        <member name="M:Spreads.Utils.BitUtil.Align(System.Int32,System.Int32)">
             <summary>
             Align a value to the next multiple up of alignment.
             If the value equals an alignment multiple then it is returned unchanged.
             <para>
             This method executes without branching. This code is designed to be use in the fast path and should not
             be used with negative numbers. Negative numbers will result in undefined behavior.
            
             </para>
             </summary>
             <param name="value">     to be aligned up. </param>
             <param name="alignment"> to be used. </param>
             <returns> the value aligned to the next boundary. </returns>
        </member>
        <member name="M:Spreads.Utils.BitUtil.FromHexByteArray(System.Byte[])">
            <summary>
            Generate a byte array from the hex representation of the given byte array.
            </summary>
            <param name="buffer"> to convert from a hex representation (in Big Endian) </param>
            <returns> new byte array that is decimal representation of the passed array </returns>
        </member>
        <member name="M:Spreads.Utils.BitUtil.ToHexByteArray(System.Byte[])">
            <summary>
            Generate a byte array that is a hex representation of a given byte array.
            </summary>
            <param name="buffer"> to convert to a hex representation </param>
            <returns> new byte array that is hex representation (in Big Endian) of the passed array </returns>
        </member>
        <member name="M:Spreads.Utils.BitUtil.ToHexByteArray(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate a byte array that is a hex representation of a given byte array.
            </summary>
            <param name="buffer"> to convert to a hex representation </param>
            <param name="offset"> the offset into the buffer </param>
            <param name="length"> the number of bytes to convert </param>
            <returns> new byte array that is hex representation (in Big Endian) of the passed array </returns>
        </member>
        <member name="M:Spreads.Utils.BitUtil.FromHex(System.String)">
            <summary>
            Generate a byte array from a string that is the hex representation of the given byte array.
            </summary>
            <param name="value"> to convert from a hex representation (in Big Endian) </param>
            <returns> new byte array holding the decimal representation of the passed array </returns>
        </member>
        <member name="M:Spreads.Utils.BitUtil.ToHex(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate a string that is the hex representation of a given byte array.
            </summary>
            <param name="buffer"> to convert to a hex representation </param>
            <param name="offset"> the offset into the buffer </param>
            <param name="length"> the number of bytes to convert </param>
            <returns> new String holding the hex representation (in Big Endian) of the passed array </returns>
        </member>
        <member name="M:Spreads.Utils.BitUtil.ToHex(System.Byte[])">
            <summary>
            Generate a string that is the hex representation of a given byte array.
            </summary>
            <param name="buffer"> to convert to a hex representation </param>
            <returns> new String holding the hex representation (in Big Endian) of the passed array </returns>
        </member>
        <member name="M:Spreads.Utils.BitUtil.IsEven(System.Int32)">
            <summary>
            Is a number even.
            </summary>
            <param name="value"> to check. </param>
            <returns> true if the number is even otherwise false. </returns>
        </member>
        <member name="M:Spreads.Utils.BitUtil.IsPowerOfTwo(System.Int32)">
            <summary>
            Is a value a positive power of two.
            </summary>
            <param name="value"> to be checked. </param>
            <returns> true if the number is a positive power of two otherwise false. </returns>
        </member>
        <member name="M:Spreads.Utils.BitUtil.Next(System.Int32,System.Int32)">
            <summary>
            Cycles indices of an array one at a time in a forward fashion
            </summary>
            <param name="current"> value to be incremented. </param>
            <param name="max">     value for the cycle. </param>
            <returns> the next value, or zero if max is reached. </returns>
        </member>
        <member name="M:Spreads.Utils.BitUtil.Previous(System.Int32,System.Int32)">
            <summary>
            Cycles indices of an array one at a time in a backwards fashion
            </summary>
            <param name="current"> value to be decremented. </param>
            <param name="max">     value of the cycle. </param>
            <returns> the next value, or max - 1 if current is zero </returns>
        </member>
        <member name="M:Spreads.Utils.BitUtil.IsAligned(System.Int64,System.Int32)">
            <summary>
            Is an address aligned on a boundary.
            </summary>
            <param name="address">   to be tested. </param>
            <param name="alignment"> boundary the address is tested against. </param>
            <returns> true if the address is on the aligned boundary otherwise false. </returns>
            <exception cref="T:System.ArgumentException"> if the alignment is not a power of 2` </exception>
        </member>
        <member name="T:Spreads.Utils.Bootstrap.ABI">
            <summary>Application binary interface.</summary>
            <seealso />
        </member>
        <member name="F:Spreads.Utils.Bootstrap.ABI.Unknown">
            <summary>Application binary interface not known to the library.</summary>
            <remarks>This value is never returned on supported platforms.</remarks>
        </member>
        <member name="F:Spreads.Utils.Bootstrap.ABI.Windows_X86">
            <summary>Windows x86 ABI.</summary>
        </member>
        <member name="F:Spreads.Utils.Bootstrap.ABI.Windows_X86_64">
            <summary>Windows x86-64 ABI.</summary>
        </member>
        <member name="F:Spreads.Utils.Bootstrap.ABI.Windows_IA64">
            <summary>Windows IA64 ABI.</summary>
        </member>
        <member name="F:Spreads.Utils.Bootstrap.ABI.Windows_ARM">
            <summary>Windows ARM ABI.</summary>
        </member>
        <member name="F:Spreads.Utils.Bootstrap.ABI.OSX_X86">
            <summary>OS X x86 ABI.</summary>
        </member>
        <member name="F:Spreads.Utils.Bootstrap.ABI.OSX_X86_64">
            <summary>OS X x86-64 ABI.</summary>
        </member>
        <member name="F:Spreads.Utils.Bootstrap.ABI.OSX_PPC">
            <summary>OS X PowerPC ABI.</summary>
        </member>
        <member name="F:Spreads.Utils.Bootstrap.ABI.OSX_PPC64">
            <summary>OS X PowerPC 64 ABI.</summary>
        </member>
        <member name="F:Spreads.Utils.Bootstrap.ABI.Linux_X86">
            <summary>Linux x86 ABI.</summary>
        </member>
        <member name="F:Spreads.Utils.Bootstrap.ABI.Linux_X86_64">
            <summary>Linux x86-64 ABI.</summary>
        </member>
        <member name="F:Spreads.Utils.Bootstrap.ABI.Linux_X32">
            <summary>Linux x32 ABI.</summary>
        </member>
        <member name="F:Spreads.Utils.Bootstrap.ABI.Linux_IA64">
            <summary>Linux IA64 ABI.</summary>
        </member>
        <member name="F:Spreads.Utils.Bootstrap.ABI.Linux_K1OM">
            <summary>Linux K1OM (Xeon Phi) ABI.</summary>
        </member>
        <member name="F:Spreads.Utils.Bootstrap.ABI.Linux_ARM">
            <summary>Linux Legacy ARM ABI (OABI).</summary>
        </member>
        <member name="F:Spreads.Utils.Bootstrap.ABI.Linux_ARMEL">
            <summary>Linux ARM EABI with soft-float calling convention (armel, gnueabi).</summary>
        </member>
        <member name="F:Spreads.Utils.Bootstrap.ABI.Linux_ARMHF">
            <summary>Linux ARM EABI with hard-float calling convention (armhf, gnueabihf).</summary>
        </member>
        <member name="F:Spreads.Utils.Bootstrap.ABI.Linux_ARM64">
            <summary>Linux ARM64 (AArch64) ABI.</summary>
        </member>
        <member name="F:Spreads.Utils.Bootstrap.ABI.Linux_PPC">
            <summary>Linux PowerPC ABI.</summary>
        </member>
        <member name="F:Spreads.Utils.Bootstrap.ABI.Linux_PPC64">
            <summary>Linux PowerPC 64 ABI.</summary>
        </member>
        <member name="M:Spreads.Utils.Bootstrap.ABI.Equals(Spreads.Utils.Bootstrap.ABI)">
            <summary>Compares for equality with another <see cref="T:Spreads.Utils.Bootstrap.ABI" /> object.</summary>
            <remarks>Comparison is performed by value.</remarks>
        </member>
        <member name="M:Spreads.Utils.Bootstrap.ABI.Equals(System.Object)">
            <summary>Compares for equality with another object.</summary>
            <remarks>Comparison is performed by value.</remarks>
        </member>
        <member name="M:Spreads.Utils.Bootstrap.ABI.GetHashCode">
            <summary>Provides a hash for the object.</summary>
            <remarks>Non-equal <see cref="T:Spreads.Utils.Bootstrap.ABI" /> objects are guaranteed to have different hashes.</remarks>
        </member>
        <member name="M:Spreads.Utils.Bootstrap.ABI.ToString">
            <summary>Provides a string ID for the object.</summary>
            <remarks>The string ID starts with a Latin letter and contains only Latin letters, digits, and underscore symbol.</remarks>
            <seealso cref="P:Spreads.Utils.Bootstrap.ABI.Description" />
        </member>
        <member name="M:Spreads.Utils.Bootstrap.ABI.IsWindows">
            <summary>Checks if the object represents one of Windows-specific ABIs.</summary>
            <returns>true if this is a Windows ABI and false otherwise.</returns>
            <seealso cref="M:Spreads.Utils.Bootstrap.ABI.IsUnix" />
            <seealso cref="M:Spreads.Utils.Bootstrap.ABI.IsLinux" />
            <seealso cref="M:Spreads.Utils.Bootstrap.ABI.IsOSX" />
        </member>
        <member name="M:Spreads.Utils.Bootstrap.ABI.IsUnix">
            <summary>Checks if the object represents one of Unix-specific ABIs.</summary>
            <returns>true if this is a Unix ABI and false otherwise.</returns>
            <seealso cref="M:Spreads.Utils.Bootstrap.ABI.IsOSX" />
            <seealso cref="M:Spreads.Utils.Bootstrap.ABI.IsLinux" />
            <seealso cref="M:Spreads.Utils.Bootstrap.ABI.IsWindows" />
        </member>
        <member name="M:Spreads.Utils.Bootstrap.ABI.IsLinux">
            <summary>Checks if the object represents one of Linux-specific ABIs.</summary>
            <returns>true if this is a Linux ABI and false otherwise.</returns>
            <seealso cref="M:Spreads.Utils.Bootstrap.ABI.IsUnix" />
            <seealso cref="M:Spreads.Utils.Bootstrap.ABI.IsOSX" />
            <seealso cref="M:Spreads.Utils.Bootstrap.ABI.IsWindows" />
        </member>
        <member name="M:Spreads.Utils.Bootstrap.ABI.IsOSX">
            <summary>Checks if the object represents one of OSX-specific ABIs.</summary>
            <returns>true if this is an OSX ABI and false otherwise.</returns>
            <seealso cref="M:Spreads.Utils.Bootstrap.ABI.IsUnix" />
            <seealso cref="M:Spreads.Utils.Bootstrap.ABI.IsLinux" />
            <seealso cref="M:Spreads.Utils.Bootstrap.ABI.IsWindows" />
        </member>
        <member name="P:Spreads.Utils.Bootstrap.ABI.Description">
            <summary>Provides a description for the object.</summary>
            <remarks>The description can contain spaces and non-ASCII characters.</remarks>
            <seealso cref="M:Spreads.Utils.Bootstrap.ABI.ToString" />
        </member>
        <member name="M:Spreads.Utils.Bootstrap.Program.Main(System.String[])">
             <summary>
            
             </summary>
        </member>
        <member name="F:Spreads.Utils.Bootstrap.Bootstrapper.rootFolder">
            <summary>
            in AppData and AppDataLocal
            </summary>
        </member>
        <member name="M:Spreads.Utils.Bootstrap.Bootstrapper.Bootstrap``1(System.String,System.String[],System.Action,System.Action{Spreads.Utils.Bootstrap.NativeLibrary},System.Action)">
            <summary>
            From assembly with type T load libraries
            </summary>
        </member>
        <member name="T:Spreads.Utils.Bootstrap.Version">
            <summary>Contains information about @Yeppp library version.</summary>
        </member>
        <member name="P:Spreads.Utils.Bootstrap.Version.Major">
            <summary>The major version number of Yeppp! library.</summary>
            <remarks>Library releases with the same major versions are guaranteed to be API- and ABI-compatible.</remarks>
        </member>
        <member name="P:Spreads.Utils.Bootstrap.Version.Minor">
            <summary>The minor version number of Yeppp! library.</summary>
            <remarks>A change in minor versions indicates addition of new features, and major bug-fixes.</remarks>
        </member>
        <member name="P:Spreads.Utils.Bootstrap.Version.Patch">
            <summary>The patch level of Yeppp! library.</summary>
            <remarks>A version with a higher patch level indicates minor bug-fixes.</remarks>
        </member>
        <member name="P:Spreads.Utils.Bootstrap.Version.Build">
            <summary>The build number of Yeppp! library.</summary>
            <remarks>The build number is unique for the fixed combination of major, minor, and patch-level versions.</remarks>
        </member>
        <member name="P:Spreads.Utils.Bootstrap.Version.ReleaseName">
            <summary>Human-readable name of this release of Yeppp! library</summary>
            <remarks>The release name may contain non-ASCII characters.</remarks>
        </member>
        <member name="M:Spreads.Utils.Bootstrap.Version.ToString">
            <summary>Provides a string representation for all parts of the version.</summary>
            <returns>The full version string in the format "major.minor.patch.build (release name)".</returns>
        </member>
        <member name="T:Spreads.Utils.ByteUtil">
            <summary>
            Utility to copy blocks of memory
            </summary>
        </member>
        <member name="T:Spreads.Utils.ChaosMonkey">
            <summary>
            When enabled via <see cref="P:Spreads.Settings.EnableChaosMonkey"/>,
            calling the methods will raise an error with a given probability
            </summary>
        </member>
        <member name="P:Spreads.Utils.ChaosMonkey.Force">
            <summary>
            Forces *once* any exception regardless of probability.
            </summary>
        </member>
        <member name="T:Spreads.Utils.FastMember.MemberSet">
            <summary>
            Represents an abstracted view of the members defined for a type
            </summary>
        </member>
        <member name="M:Spreads.Utils.FastMember.MemberSet.GetEnumerator">
            <summary>
            Return a sequence of all defined members
            </summary>
        </member>
        <member name="P:Spreads.Utils.FastMember.MemberSet.Item(System.Int32)">
            <summary>
            Get a member by index
            </summary>
        </member>
        <member name="P:Spreads.Utils.FastMember.MemberSet.Count">
            <summary>
            The number of members defined for this type
            </summary>
        </member>
        <member name="T:Spreads.Utils.FastMember.Member">
            <summary>
            Represents an abstracted view of an individual member defined for a type
            </summary>
        </member>
        <member name="P:Spreads.Utils.FastMember.Member.Name">
            <summary>
            The name of this member
            </summary>
        </member>
        <member name="P:Spreads.Utils.FastMember.Member.Type">
            <summary>
            The type of value stored in this member
            </summary>
        </member>
        <member name="M:Spreads.Utils.FastMember.Member.IsDefined(System.Type)">
            <summary>
            Is the attribute specified defined on this type
            </summary>
        </member>
        <member name="M:Spreads.Utils.FastMember.Member.GetAttribute(System.Type,System.Boolean)">
            <summary>
            Getting Attribute Type
            </summary>
        </member>
        <member name="P:Spreads.Utils.FastMember.Member.CanWrite">
            <summary>
            Property Can Write
            </summary>
        </member>
        <member name="P:Spreads.Utils.FastMember.Member.CanRead">
            <summary>
            Property Can Read
            </summary>
        </member>
        <member name="T:Spreads.Utils.FastMember.ObjectAccessor">
            <summary>
            Represents an individual object, allowing access to members by-name
            </summary>
        </member>
        <member name="P:Spreads.Utils.FastMember.ObjectAccessor.Item(System.String)">
            <summary>
            Get or Set the value of a named member for the underlying object
            </summary>
        </member>
        <member name="P:Spreads.Utils.FastMember.ObjectAccessor.Target">
            <summary>
            The object represented by this instance
            </summary>
        </member>
        <member name="M:Spreads.Utils.FastMember.ObjectAccessor.Equals(System.Object)">
            <summary>
            Use the target types definition of equality
            </summary>
        </member>
        <member name="M:Spreads.Utils.FastMember.ObjectAccessor.GetHashCode">
            <summary>
            Obtain the hash of the target object
            </summary>
        </member>
        <member name="M:Spreads.Utils.FastMember.ObjectAccessor.ToString">
            <summary>
            Use the target's definition of a string representation
            </summary>
        </member>
        <member name="M:Spreads.Utils.FastMember.ObjectAccessor.Create(System.Object)">
            <summary>
            Wraps an individual object, allowing by-name access to that instance
            </summary>
        </member>
        <member name="M:Spreads.Utils.FastMember.ObjectAccessor.Create(System.Object,System.Boolean)">
            <summary>
            Wraps an individual object, allowing by-name access to that instance
            </summary>
        </member>
        <member name="T:Spreads.Utils.FastMember.TypeAccessor">
            <summary>
            Provides by-name member-access to objects of a given type
            </summary>
        </member>
        <member name="P:Spreads.Utils.FastMember.TypeAccessor.CreateNewSupported">
            <summary>
            Does this type support new instances via a parameterless constructor?
            </summary>
        </member>
        <member name="M:Spreads.Utils.FastMember.TypeAccessor.CreateNew">
            <summary>
            Create a new instance of this type
            </summary>
        </member>
        <member name="P:Spreads.Utils.FastMember.TypeAccessor.GetMembersSupported">
            <summary>
            Can this type be queried for member availability?
            </summary>
        </member>
        <member name="M:Spreads.Utils.FastMember.TypeAccessor.GetMembers">
            <summary>
            Query the members available for this type
            </summary>
        </member>
        <member name="M:Spreads.Utils.FastMember.TypeAccessor.Create(System.Type)">
            <summary>
            Provides a type-specific accessor, allowing by-name access for all objects of that type
            </summary>
            <remarks>The accessor is cached internally; a pre-existing accessor may be returned</remarks>
        </member>
        <member name="M:Spreads.Utils.FastMember.TypeAccessor.Create(System.Type,System.Boolean)">
            <summary>
            Provides a type-specific accessor, allowing by-name access for all objects of that type
            </summary>
            <remarks>The accessor is cached internally; a pre-existing accessor may be returned</remarks>
        </member>
        <member name="T:Spreads.Utils.FastMember.TypeAccessor.RuntimeTypeAccessor">
            <summary>
            A TypeAccessor based on a Type implementation, with available member metadata
            </summary>
        </member>
        <member name="P:Spreads.Utils.FastMember.TypeAccessor.RuntimeTypeAccessor.Type">
            <summary>
            Returns the Type represented by this accessor
            </summary>
        </member>
        <member name="P:Spreads.Utils.FastMember.TypeAccessor.RuntimeTypeAccessor.GetMembersSupported">
            <summary>
            Can this type be queried for member availability?
            </summary>
        </member>
        <member name="M:Spreads.Utils.FastMember.TypeAccessor.RuntimeTypeAccessor.GetMembers">
            <summary>
            Query the members available for this type
            </summary>
        </member>
        <member name="P:Spreads.Utils.FastMember.TypeAccessor.Item(System.Object,System.String)">
            <summary>
            Get or set the value of a named member on the target instance
            </summary>
        </member>
        <member name="M:Spreads.Utils.IntUtil.NumberOfTrailingZeros(System.Int32)">
            <summary>
            Returns the number of zero bits following the lowest-order ("rightmost")
            one-bit in the two's complement binary representation of the specified
            {@code int} value.  Returns 32 if the specified value has no
            one-bits in its two's complement representation, in other words if it is
            equal to zero.
            </summary>
            <param name="i"> the value whose number of trailing zeros is to be computed </param>
            <returns> the number of zero bits following the lowest-order ("rightmost")
                one-bit in the two's complement binary representation of the
                specified {@code int} value, or 32 if the value is equal
                to zero.
            @since 1.5 </returns>
        </member>
        <member name="M:Spreads.Utils.IntUtil.NumberOfLeadingZeros(System.Int32)">
             <summary>
             Note Olivier: Direct port of the Java method Integer.NumberOfLeadingZeros
            
             Returns the number of zero bits preceding the highest-order
             ("leftmost") one-bit in the two's complement binary representation
             of the specified {@code int} value.  Returns 32 if the
             specified value has no one-bits in its two's complement representation,
             in other words if it is equal to zero.
            
             <para>Note that this method is closely related to the logarithm base 2.
             For all positive {@code int} values x:
             &lt;ul&gt;
             &lt;li&gt;floor(log&lt;sub&gt;2&lt;/sub&gt;(x)) = {@code 31 - numberOfLeadingZeros(x)}
             &lt;li&gt;ceil(log&lt;sub&gt;2&lt;/sub&gt;(x)) = {@code 32 - numberOfLeadingZeros(x - 1)}
             &lt;/ul&gt;
            
             </para>
             </summary>
             <param name="i"> the value whose number of leading zeros is to be computed </param>
             <returns> the number of zero bits preceding the highest-order
                 ("leftmost") one-bit in the two's complement binary representation
                 of the specified {@code int} value, or 32 if the value
                 is equal to zero.
             </returns>
        </member>
        <member name="M:Spreads.Utils.PooledObject`1.Init">
            <summary>
            Initialize disposed object. E.g. rent buffers that were returned to a buffer pool during Dispose.
            </summary>
        </member>
        <member name="M:Spreads.Utils.StringExtensions.MD5Guid(System.String)">
            <summary>
            Translate MD5 hash of a string UTF8 bytes to Guid
            </summary>
        </member>
        <member name="T:Spreads.RewriteAILAttribute">
            <summary>
            A marker attribute to add manually aggressive inlining attribute to IL.
            </summary>
        </member>
        <member name="M:Spreads.ThrowHelper.Assert(System.Boolean,System.String)">
             <summary>
            
             </summary>
             <param name="expectedTrueCondition"></param>
             <param name="message"></param>
        </member>
        <member name="M:Spreads.ThrowHelper.DebugAssert(System.Boolean,System.String)">
            <summary>
            Throw exception instead of just printing Fail: xxx with Debug.Assert. Zero cost in release.
            </summary>
            <param name="expectedTrueCondition"></param>
            <param name="message"></param>
        </member>
        <member name="M:Spreads.CoreUtils.CombineFilterMaps``3(System.Func{``0,System.Collections.Generic.KeyValuePair{System.Boolean,``1}},System.Func{``1,System.Collections.Generic.KeyValuePair{System.Boolean,``2}})">
            <summary>
            Chain two filterMaps together
            </summary>
        </member>
        <member name="M:Spreads.CoreUtils.CombineFilterMapWithMap``3(System.Func{``0,System.Collections.Generic.KeyValuePair{System.Boolean,``1}},System.Func{``1,``2})">
            <summary>
            Apply map to a result of filterMap
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>
                Specifies that <see langword="null"/> is allowed as an input even if the
                corresponding type disallows it.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.AllowNullAttribute.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute"/> class.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>
                Specifies that <see langword="null"/> is disallowed as an input even if the
                corresponding type allows it.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DisallowNullAttribute.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute"/> class.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>
                Specifies that a method that will never return under any circumstance.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute"/> class.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>
                Specifies that the method will not return if the associated <see cref="T:System.Boolean"/>
                parameter is passed the specified value.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>
                Gets the condition parameter value.
                Code after the method is considered unreachable by diagnostics if the argument
                to the associated parameter matches this value.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>
                Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute"/>
                class with the specified parameter value.
            </summary>
            <param name="parameterValue">
                The condition parameter value.
                Code after the method is considered unreachable by diagnostics if the argument
                to the associated parameter matches this value.
            </param>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>
                Specifies that an output may be <see langword="null"/> even if the
                corresponding type disallows it.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullAttribute.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute"/> class.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>
                Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>,
                the parameter may be <see langword="null"/> even if the corresponding type disallows it.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>
                Gets the return value condition.
                If the method returns this value, the associated parameter may be <see langword="null"/>.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>
                 Initializes the attribute with the specified return value condition.
            </summary>
            <param name="returnValue">
                The return value condition.
                If the method returns this value, the associated parameter may be <see langword="null"/>.
            </param>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>
                Specifies that an output is not <see langword="null"/> even if the
                corresponding type allows it.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullAttribute.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.NotNullAttribute"/> class.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>
                Specifies that the output will be non-<see langword="null"/> if the
                named parameter is non-<see langword="null"/>.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>
                Gets the associated parameter name.
                The output will be non-<see langword="null"/> if the argument to the
                parameter specified is non-<see langword="null"/>.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>
                Initializes the attribute with the associated parameter name.
            </summary>
            <param name="parameterName">
                The associated parameter name.
                The output will be non-<see langword="null"/> if the argument to the
                parameter specified is non-<see langword="null"/>.
            </param>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>
                Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>,
                the parameter will not be <see langword="null"/> even if the corresponding type allows it.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>
                Gets the return value condition.
                If the method returns this value, the associated parameter will not be <see langword="null"/>.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>
                Initializes the attribute with the specified return value condition.
            </summary>
            <param name="returnValue">
                The return value condition.
                If the method returns this value, the associated parameter will not be <see langword="null"/>.
            </param>
        </member>
    </members>
</doc>
