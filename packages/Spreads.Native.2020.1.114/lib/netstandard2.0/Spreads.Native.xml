<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Spreads.Native</name>
    </assembly>
    <members>
        <member name="T:Spreads.Native.Bootstrap.ABI">
            <summary>Application binary interface.</summary>
            <seealso />
        </member>
        <member name="F:Spreads.Native.Bootstrap.ABI.Unknown">
            <summary>Application binary interface not known to the library.</summary>
            <remarks>This value is never returned on supported platforms.</remarks>
        </member>
        <member name="F:Spreads.Native.Bootstrap.ABI.Windows_X86">
            <summary>Windows x86 ABI.</summary>
        </member>
        <member name="F:Spreads.Native.Bootstrap.ABI.Windows_X86_64">
            <summary>Windows x86-64 ABI.</summary>
        </member>
        <member name="F:Spreads.Native.Bootstrap.ABI.Windows_IA64">
            <summary>Windows IA64 ABI.</summary>
        </member>
        <member name="F:Spreads.Native.Bootstrap.ABI.Windows_ARM">
            <summary>Windows ARM ABI.</summary>
        </member>
        <member name="F:Spreads.Native.Bootstrap.ABI.OSX_X86">
            <summary>OS X x86 ABI.</summary>
        </member>
        <member name="F:Spreads.Native.Bootstrap.ABI.OSX_X86_64">
            <summary>OS X x86-64 ABI.</summary>
        </member>
        <member name="F:Spreads.Native.Bootstrap.ABI.OSX_PPC">
            <summary>OS X PowerPC ABI.</summary>
        </member>
        <member name="F:Spreads.Native.Bootstrap.ABI.OSX_PPC64">
            <summary>OS X PowerPC 64 ABI.</summary>
        </member>
        <member name="F:Spreads.Native.Bootstrap.ABI.Linux_X86">
            <summary>Linux x86 ABI.</summary>
        </member>
        <member name="F:Spreads.Native.Bootstrap.ABI.Linux_X86_64">
            <summary>Linux x86-64 ABI.</summary>
        </member>
        <member name="F:Spreads.Native.Bootstrap.ABI.Linux_X32">
            <summary>Linux x32 ABI.</summary>
        </member>
        <member name="F:Spreads.Native.Bootstrap.ABI.Linux_IA64">
            <summary>Linux IA64 ABI.</summary>
        </member>
        <member name="F:Spreads.Native.Bootstrap.ABI.Linux_K1OM">
            <summary>Linux K1OM (Xeon Phi) ABI.</summary>
        </member>
        <member name="F:Spreads.Native.Bootstrap.ABI.Linux_ARM">
            <summary>Linux Legacy ARM ABI (OABI).</summary>
        </member>
        <member name="F:Spreads.Native.Bootstrap.ABI.Linux_ARMEL">
            <summary>Linux ARM EABI with soft-float calling convention (armel, gnueabi).</summary>
        </member>
        <member name="F:Spreads.Native.Bootstrap.ABI.Linux_ARMHF">
            <summary>Linux ARM EABI with hard-float calling convention (armhf, gnueabihf).</summary>
        </member>
        <member name="F:Spreads.Native.Bootstrap.ABI.Linux_ARM64">
            <summary>Linux ARM64 (AArch64) ABI.</summary>
        </member>
        <member name="F:Spreads.Native.Bootstrap.ABI.Linux_PPC">
            <summary>Linux PowerPC ABI.</summary>
        </member>
        <member name="F:Spreads.Native.Bootstrap.ABI.Linux_PPC64">
            <summary>Linux PowerPC 64 ABI.</summary>
        </member>
        <member name="M:Spreads.Native.Bootstrap.ABI.Equals(Spreads.Native.Bootstrap.ABI)">
            <summary>Compares for equality with another <see cref="T:Spreads.Native.Bootstrap.ABI" /> object.</summary>
            <remarks>Comparison is performed by value.</remarks>
        </member>
        <member name="M:Spreads.Native.Bootstrap.ABI.Equals(System.Object)">
            <summary>Compares for equality with another object.</summary>
            <remarks>Comparison is performed by value.</remarks>
        </member>
        <member name="M:Spreads.Native.Bootstrap.ABI.GetHashCode">
            <summary>Provides a hash for the object.</summary>
            <remarks>Non-equal <see cref="T:Spreads.Native.Bootstrap.ABI" /> objects are guaranteed to have different hashes.</remarks>
        </member>
        <member name="M:Spreads.Native.Bootstrap.ABI.ToString">
            <summary>Provides a string ID for the object.</summary>
            <remarks>The string ID starts with a Latin letter and contains only Latin letters, digits, and underscore symbol.</remarks>
            <seealso cref="P:Spreads.Native.Bootstrap.ABI.Description" />
        </member>
        <member name="M:Spreads.Native.Bootstrap.ABI.IsWindows">
            <summary>Checks if the object represents one of Windows-specific ABIs.</summary>
            <returns>true if this is a Windows ABI and false otherwise.</returns>
            <seealso cref="M:Spreads.Native.Bootstrap.ABI.IsUnix" />
            <seealso cref="M:Spreads.Native.Bootstrap.ABI.IsLinux" />
            <seealso cref="M:Spreads.Native.Bootstrap.ABI.IsOSX" />
        </member>
        <member name="M:Spreads.Native.Bootstrap.ABI.IsUnix">
            <summary>Checks if the object represents one of Unix-specific ABIs.</summary>
            <returns>true if this is a Unix ABI and false otherwise.</returns>
            <seealso cref="M:Spreads.Native.Bootstrap.ABI.IsOSX" />
            <seealso cref="M:Spreads.Native.Bootstrap.ABI.IsLinux" />
            <seealso cref="M:Spreads.Native.Bootstrap.ABI.IsWindows" />
        </member>
        <member name="M:Spreads.Native.Bootstrap.ABI.IsLinux">
            <summary>Checks if the object represents one of Linux-specific ABIs.</summary>
            <returns>true if this is a Linux ABI and false otherwise.</returns>
            <seealso cref="M:Spreads.Native.Bootstrap.ABI.IsUnix" />
            <seealso cref="M:Spreads.Native.Bootstrap.ABI.IsOSX" />
            <seealso cref="M:Spreads.Native.Bootstrap.ABI.IsWindows" />
        </member>
        <member name="M:Spreads.Native.Bootstrap.ABI.IsOSX">
            <summary>Checks if the object represents one of OSX-specific ABIs.</summary>
            <returns>true if this is an OSX ABI and false otherwise.</returns>
            <seealso cref="M:Spreads.Native.Bootstrap.ABI.IsUnix" />
            <seealso cref="M:Spreads.Native.Bootstrap.ABI.IsLinux" />
            <seealso cref="M:Spreads.Native.Bootstrap.ABI.IsWindows" />
        </member>
        <member name="P:Spreads.Native.Bootstrap.ABI.Description">
            <summary>Provides a description for the object.</summary>
            <remarks>The description can contain spaces and non-ASCII characters.</remarks>
            <seealso cref="M:Spreads.Native.Bootstrap.ABI.ToString" />
        </member>
        <member name="P:Spreads.Native.Bootstrap.Bootstrapper.DefaultAppName">
             <summary>
            
             </summary>
        </member>
        <member name="M:Spreads.Native.Bootstrap.Bootstrapper.Init(System.String,System.String)">
            <summary>
            If <paramref name="appName"/> if provided then <see cref="P:Spreads.Native.Bootstrap.Bootstrapper.AppFolder"/> is set to
            <paramref name="appName"/> inside <see cref="F:System.Environment.SpecialFolder.LocalApplicationData"/>.
            If <paramref name="appFolderPath"/> is provided then <see cref="P:Spreads.Native.Bootstrap.Bootstrapper.AppFolder"/>  is set to it.
            One one of the parameters could be not null.
            </summary>
            <param name="appName"></param>
            <param name="appFolderPath"></param>
        </member>
        <member name="M:Spreads.Native.Bootstrap.Bootstrapper.Bootstrap``1(System.String,System.Action{Spreads.Native.Bootstrap.Bootstrapper},System.Action{Spreads.Native.Bootstrap.NativeLibrary},System.Action,System.String)">
            <summary>
            Load libraries from an assembly with type <typeparamref name="T"/>.
            Executes only once. Calls after the first one are noops.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="nativeLibraryName"></param>
            <param name="preLoadAction"></param>
            <param name="postLoadAction"></param>
            <param name="disposeAction"></param>
            <param name="nativeLoadPathOverride">
            Path to a directory with the native library. On Linux DllImport won't work with a custom path
            and you could setup delegates to native methods from <paramref name="postLoadAction"/>.</param>
        </member>
        <member name="T:Spreads.Native.Bootstrap.Version">
            <summary>Contains information about @Yeppp library version.</summary>
        </member>
        <member name="P:Spreads.Native.Bootstrap.Version.Major">
            <summary>The major version number of Yeppp! library.</summary>
            <remarks>Library releases with the same major versions are guaranteed to be API- and ABI-compatible.</remarks>
        </member>
        <member name="P:Spreads.Native.Bootstrap.Version.Minor">
            <summary>The minor version number of Yeppp! library.</summary>
            <remarks>A change in minor versions indicates addition of new features, and major bug-fixes.</remarks>
        </member>
        <member name="P:Spreads.Native.Bootstrap.Version.Patch">
            <summary>The patch level of Yeppp! library.</summary>
            <remarks>A version with a higher patch level indicates minor bug-fixes.</remarks>
        </member>
        <member name="P:Spreads.Native.Bootstrap.Version.Build">
            <summary>The build number of Yeppp! library.</summary>
            <remarks>The build number is unique for the fixed combination of major, minor, and patch-level versions.</remarks>
        </member>
        <member name="P:Spreads.Native.Bootstrap.Version.ReleaseName">
            <summary>Human-readable name of this release of Yeppp! library</summary>
            <remarks>The release name may contain non-ASCII characters.</remarks>
        </member>
        <member name="M:Spreads.Native.Bootstrap.Version.ToString">
            <summary>Provides a string representation for all parts of the version.</summary>
            <returns>The full version string in the format "major.minor.patch.build (release name)".</returns>
        </member>
        <member name="T:Spreads.Native.Compression">
            <summary>
            Native compression methods.
            </summary>
        </member>
        <member name="T:Spreads.Native.IDelta`1">
            <summary>
            An interface for a type whose value could be stored as a delta from a previous value and recovered later.
            Delta is the same type as a value. E.g. all numeric types could implement this interface with plus and minus operations.
            </summary>
        </member>
        <member name="M:Spreads.Native.IDelta`1.AddDelta(`0)">
            <summary>
            This + Delta = New valid value
            </summary>
        </member>
        <member name="M:Spreads.Native.IDelta`1.GetDelta(`0)">
            <summary>
            This - Other = Delta so that: other.AddDelta(this.GetDelta(other)) == this.
            </summary>
        </member>
        <member name="T:Spreads.Native.IInt64Diffable`1">
            <summary>
            An interface for a type whose value could be stored as an Int64 delta from a previous value and recovered later by addition.
            </summary>
            <seealso cref="T:Spreads.Native.IDelta`1"/>
        </member>
        <member name="M:Spreads.Native.IInt64Diffable`1.Add(System.Int64)">
            <summary>
            Add <paramref name="diff"/> to this value as long.
            </summary>
        </member>
        <member name="M:Spreads.Native.IInt64Diffable`1.Diff(`0)">
            <summary>
            This as long minus <paramref name="subtrahend"/> as long.
            </summary>
            <param name="subtrahend">A value that is subtracted from this value.</param>
        </member>
        <member name="T:Spreads.Native.UnsafeEx">
            <summary>
            Contains unsafe IL methods useful for Spreads.
            </summary>
            <seealso cref="T:System.Runtime.CompilerServices.Unsafe"/>
        </member>
        <member name="M:Spreads.Native.UnsafeEx.CompareToConstrained``1(``0@,``0@)">
            <summary>
            Calls <see cref="M:System.IComparable`1.CompareTo(`0)"/> method on a generic <paramref name="left"/> with the <seealso cref="F:System.Reflection.Emit.OpCodes.Constrained"/> IL instruction.
            If the type <typeparamref name="T"/> does not implement <see cref="T:System.IComparable`1"/> bad things will happen.
            Use static readonly bool field in a generic class that caches reflection check if the type implements the interface.
            </summary>
        </member>
        <member name="M:Spreads.Native.UnsafeEx.EqualsConstrained``1(``0@,``0@)">
            <summary>
            Calls <see cref="M:System.IEquatable`1.Equals(`0)"/> method on a generic <paramref name="left"/> with the <seealso cref="F:System.Reflection.Emit.OpCodes.Constrained"/> IL instruction.
            If the type <typeparamref name="T"/> does not implement <see cref="T:System.IEquatable`1"/> bad things will happen.
            Use static readonly bool field in a generic class that caches reflection check if the type implements the interface.
            </summary>
        </member>
        <member name="M:Spreads.Native.UnsafeEx.GetHashCodeConstrained``1(``0@)">
            <summary>
            Calls <see cref="M:System.Object.GetHashCode"/> method on a generic <paramref name="obj"/> with the <seealso cref="F:System.Reflection.Emit.OpCodes.Constrained"/> IL instruction.
            </summary>
        </member>
        <member name="M:Spreads.Native.UnsafeEx.DisposeConstrained``1(``0@)">
            <summary>
            Calls <see cref="M:System.IDisposable.Dispose"/> method on a generic <paramref name="obj"/> with the <seealso cref="F:System.Reflection.Emit.OpCodes.Constrained"/> IL instruction.
            If the type <typeparamref name="T"/> does not implement <see cref="T:System.IDisposable"/> bad things will happen.
            Use static readonly bool field in a generic class that caches reflection check if the type implements the interface.
            </summary>
        </member>
        <member name="M:Spreads.Native.UnsafeEx.AddDeltaConstrained``1(``0@,``0@)">
            <summary>
            Calls <see cref="M:Spreads.Native.IDelta`1.AddDelta(`0)"/> method on a generic <paramref name="obj"/> with the <seealso cref="F:System.Reflection.Emit.OpCodes.Constrained"/> IL instruction.
            If the type <typeparamref name="T"/> does not implement <see cref="T:Spreads.Native.IDelta`1"/> bad things will happen.
            Use static readonly bool field in a generic class that caches reflection check if the type implements the interface.
            </summary>
        </member>
        <member name="M:Spreads.Native.UnsafeEx.GetDeltaConstrained``1(``0@,``0@)">
            <summary>
            Calls <see cref="M:Spreads.Native.IDelta`1.GetDelta(`0)"/> method on a generic <paramref name="obj"/> with the <seealso cref="F:System.Reflection.Emit.OpCodes.Constrained"/> IL instruction.
            If the type <typeparamref name="T"/> does not implement <see cref="T:Spreads.Native.IDelta`1"/> bad things will happen.
            Use static readonly bool field in a generic class that caches reflection check if the type implements the interface.
            </summary>
        </member>
        <member name="M:Spreads.Native.UnsafeEx.AddLongConstrained``1(``0@,System.Int64)">
            <summary>
            Calls <see cref="M:Spreads.Native.IInt64Diffable`1.Add(System.Int64)"/> method on a generic <paramref name="obj"/> with the <seealso cref="F:System.Reflection.Emit.OpCodes.Constrained"/> IL instruction.
            If the type <typeparamref name="T"/> does not implement <see cref="T:Spreads.Native.IInt64Diffable`1"/> bad things will happen.
            Use static readonly bool field in a generic class that caches reflection check if the type implements the interface.
            </summary>
        </member>
        <member name="M:Spreads.Native.UnsafeEx.DiffLongConstrained``1(``0@,``0@)">
            <summary>
            Calls <see cref="M:Spreads.Native.IInt64Diffable`1.Diff(`0)"/> method on a generic <paramref name="left"/> with the <seealso cref="F:System.Reflection.Emit.OpCodes.Constrained"/> IL instruction.
            If the type <typeparamref name="T"/> does not implement <see cref="T:Spreads.Native.IInt64Diffable`1"/> bad things will happen.
            Use static readonly bool field in a generic class that caches reflection check if the type implements the interface.
            </summary>
        </member>
        <member name="M:Spreads.Native.UnsafeEx.GetRef``1(System.Object,System.IntPtr,System.Int32)">
            <summary>
            Takes a (possibly null) object reference, plus an offset in bytes,
            adds them, and safely dereferences the target (untyped!) address in
            a way that the GC will be okay with.  It yields a value of type T.
            </summary>
            <param name="obj">An object (could be null)</param>
            <param name="byteOffset">Byte offset from object pointer.</param>
            <param name="index"></param>
        </member>
        <member name="M:Spreads.Native.UnsafeEx.SetterMethodPointer``1">
            <summary>
            Get a native method pointer to <see cref="M:Spreads.Native.UnsafeEx.SetAsObject``1(System.Object,System.IntPtr,System.Int32,System.Object)"/> method for type <typeparamref name="T"/>.
            The pointer should be used with <see cref="M:Spreads.Native.UnsafeEx.SetIndirect(System.Object,System.IntPtr,System.Int32,System.Object,System.IntPtr)"/> method.
            </summary>
        </member>
        <member name="M:Spreads.Native.UnsafeEx.SetterMethodPointerForType(System.Type)">
            <summary>
            Get a native method pointer to <see cref="M:Spreads.Native.UnsafeEx.SetAsObject``1(System.Object,System.IntPtr,System.Int32,System.Object)"/> method for type <paramref name="ty"/>.
            The pointer should be used with <see cref="M:Spreads.Native.UnsafeEx.SetIndirect(System.Object,System.IntPtr,System.Int32,System.Object,System.IntPtr)"/> method.
            </summary>
        </member>
        <member name="M:Spreads.Native.UnsafeEx.SetIndirect(System.Object,System.IntPtr,System.Int32,System.Object,System.IntPtr)">
            <summary>
            Set a value <paramref name="val"/> without generic parameters using <see cref="F:System.Reflection.Emit.OpCodes.Calli"/> instruction for <see cref="M:Spreads.Native.UnsafeEx.SetAsObject``1(System.Object,System.IntPtr,System.Int32,System.Object)"/>
            method pointer obtained via <see cref="M:Spreads.Native.UnsafeEx.SetterMethodPointer``1"/> or <see cref="M:Spreads.Native.UnsafeEx.SetterMethodPointerForType(System.Type)"/> methods.
            </summary>
            <remarks>Value <paramref name="val"/> is cast to underlying type as `(T)(dynamic)val`.</remarks>
        </member>
        <member name="T:Spreads.Native.Vec`1">
            <summary>
            Typed native or managed vector.
            </summary>
            <remarks>Not thread safe and not safe at all</remarks>
        </member>
        <member name="M:Spreads.Native.Vec`1.#ctor(`0[])">
            <summary>
            Creates a new Vec over the entirety of the target array.
            </summary>
            <param name="array">The target array.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
        </member>
        <member name="M:Spreads.Native.Vec`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>
            Creates a new Vec over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the Vec.</param>
            <param name="length">The number of items in the Vec.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:Spreads.Native.Vec`1.#ctor(System.Void*,System.Int32)">
            <summary>
            Creates a new Vec over the target unmanaged buffer.  Clearly this
            is quite dangerous, because we are creating arbitrarily typed T's
            out of a void*-typed block of memory.  And the length is not checked.
            But if this creation is correct, then all subsequent uses are correct.
            </summary>
            <param name="pointer">An unmanaged pointer to memory.</param>
            <param name="length">The number of <typeparamref name="T"/> elements the memory contains.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when <typeparamref name="T"/> is reference type or contains pointers and hence cannot be stored in unmanaged memory.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="length"/> is negative.
            </exception>
        </member>
        <member name="M:Spreads.Native.Vec`1.AsVec">
            <summary>
            Returns untyped <see cref="T:Spreads.Native.Vec"/> with the same data as this <see cref="T:Spreads.Native.Vec`1"/>
            </summary>
        </member>
        <member name="P:Spreads.Native.Vec`1.Length">
            <summary>
            Get the total number of elements in Vec.
            </summary>
        </member>
        <member name="P:Spreads.Native.Vec`1.IsPinned">
            <summary>
            Returns true if Vec is created via a pointer. Vec could still be manually pinned if it was created with an array of blittable types.
            </summary>
        </member>
        <member name="P:Spreads.Native.Vec`1.Item(System.Int32)">
            <summary>
            Fetches the element at the specified index.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
            Thrown when the specified index is not in range.
            </exception>
        </member>
        <member name="M:Spreads.Native.Vec`1.GetRef(System.Int32)">
            <summary>
            Returns a reference to a value at index.
            </summary>
        </member>
        <member name="M:Spreads.Native.Vec`1.DangerousGetRef(System.Int32)">
            <summary>
            Returns a reference to a value at index without bound checks.
            </summary>
        </member>
        <member name="M:Spreads.Native.Vec`1.Slice(System.Int32)">
            <summary>
            Forms a slice out of the given Vec, beginning at 'start'.
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index is not in range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:Spreads.Native.Vec`1.Slice(System.Int32,System.Int32)">
            <summary>
            Forms a slice out of the given Vec, beginning at 'start', of given length
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The desired length for the slice (exclusive).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:Spreads.Native.Vec`1.ToArray">
            <summary>
            Copies the contents of this span into a new array.  This heap
            allocates, so should generally be avoided, however it is sometimes
            necessary to bridge the gap with APIs written in terms of arrays.
            </summary>
        </member>
        <member name="M:Spreads.Native.Vec`1.GetPinnableReference">
            <summary>
            Returns a reference to the 0th element of the Vec. If the Span is empty, returns null reference.
            It can be used for pinning and is required to support the use of Vec within a fixed statement.
            </summary>
        </member>
        <member name="M:Spreads.Native.Vec`1.DangerousGetPinnableReference">
            <summary>
            This method is obsolete, use System.Runtime.InteropServices.MemoryMarshal.GetReference instead.
            Returns a reference to the 0th element of the Span. If the Span is empty, returns a reference to the location where the 0th element
            would have been stored. Such a reference can be used for pinning but must never be dereferenced.
            </summary>
        </member>
        <member name="M:Spreads.Native.Vec`1.Clear">
            <summary>
            Clears the contents of this Vec.
            </summary>
        </member>
        <member name="M:Spreads.Native.Vec`1.Fill(`0)">
            <summary>
            Fills the contents of this Vec with the given value.
            </summary>
        </member>
        <member name="M:Spreads.Native.Vec`1.CopyTo(Spreads.Native.Vec{`0})">
             <summary>
             Copies the contents of this Vec into destination Vec. If the source
             and destinations overlap, this method behaves as if the original values in
             a temporary location before the destination is overwritten.
            
             <param name="destination">The Vec to copy items into.</param>
             <exception cref="T:System.ArgumentException">
             Thrown when the destination Span is shorter than the source Span.
             </exception>
             </summary>
        </member>
        <member name="M:Spreads.Native.Vec`1.TryCopyTo(Spreads.Native.Vec{`0})">
             <summary>
             Copies the contents of this Vec into destination Vec. If the source
             and destinations overlap, this method behaves as if the original values in
             a temporary location before the destination is overwritten.
            
             <returns>If the destination Vec is shorter than the source Vec, this method
             return false and no data is written to the destination.</returns>
             </summary>
             <param name="destination">The Vec to copy items into.</param>
        </member>
        <member name="M:Spreads.Native.Vec`1.ReferenceEquals(Spreads.Native.Vec{`0})">
            <summary>
            Returns true if left and right point at the same memory and have the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        </member>
        <member name="M:Spreads.Native.Vec`1.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> with the name of the type and the number of elements.
            </summary>
        </member>
        <member name="M:Spreads.Native.Vec`1.GetEnumerator">
            <summary>
            Returns an enumerator over the Slice's entire contents.
            </summary>
        </member>
        <member name="T:Spreads.Native.Vec`1.Enumerator">
            <summary>
            A struct-based enumerator, to make fast enumerations possible.
            This isn't designed for direct use, instead see GetEnumerator.
            </summary>
        </member>
        <member name="T:Spreads.Native.Vec">
            <summary>
            Untyped native or managed vector.
            </summary>
            <remarks>Not thread safe and not safe at all</remarks>
        </member>
        <member name="M:Spreads.Native.Vec.#ctor(System.Array)">
            <summary>
            Creates a new Vec over the entirety of the target array.
            </summary>
            <param name="array">The target array.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
        </member>
        <member name="M:Spreads.Native.Vec.#ctor(System.Array,System.Int32,System.Int32)">
            <summary>
            Creates a new Vec over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the Vec.</param>
            <param name="length">The number of items in the Vec.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:Spreads.Native.Vec.#ctor(System.Void*,System.Int32,System.Type)">
            <summary>
            Creates a new Vec over the target unmanaged buffer.  Clearly this
            is quite dangerous, because we are creating arbitrarily typed T's
            out of a void*-typed block of memory.  And the length is not checked.
            But if this creation is correct, then all subsequent uses are correct.
            </summary>
            <param name="pointer">An unmanaged pointer to memory.</param>
            <param name="length">The number of elements the memory contains.</param>
            <param name="elementType">Element type.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="length"/> is negative.
            </exception>
        </member>
        <member name="M:Spreads.Native.Vec.#ctor(System.Array,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            An internal helper for creating Vecs.  Not for public use.
            </summary>
        </member>
        <member name="M:Spreads.Native.Vec.As``1">
            <summary>
            Returns typed <see cref="T:Spreads.Native.Vec`1"/> with the same data as this <see cref="T:Spreads.Native.Vec"/>
            </summary>
        </member>
        <member name="P:Spreads.Native.Vec.Length">
            <summary>
            Get the total number of elements in Vec.
            </summary>
        </member>
        <member name="P:Spreads.Native.Vec.IsPinned">
            <summary>
            Returns true if Vec is created via a pointer. Vec could still be manually pinned if it was create with an array of blittable types.
            </summary>
        </member>
        <member name="P:Spreads.Native.Vec.Item(System.Int32)">
            <summary>
            Fetches the element at the specified index.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
            Thrown when the specified index is not in range.
            </exception>
        </member>
        <member name="M:Spreads.Native.Vec.DangerousGet(System.Int32)">
            <summary>
            Fetches the element at the specified index without bound checks.
            </summary>
        </member>
        <member name="M:Spreads.Native.Vec.Get``1(System.Int32)">
            <summary>
            Returns the element at the specified index.
            </summary>
        </member>
        <member name="M:Spreads.Native.Vec.GetRef``1(System.Int32)">
            <summary>
            Get a typed reference to a value at index.
            </summary>
        </member>
        <member name="M:Spreads.Native.Vec.DangerousGetRef``1(System.Int32)">
            <summary>
            Get a typed reference to a value at index without type or bounds check.
            </summary>
        </member>
        <member name="M:Spreads.Native.Vec.Slice(System.Int32)">
            <summary>
            Forms a slice out of the given Vec, beginning at 'start'.
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index is not in range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:Spreads.Native.Vec.Slice(System.Int32,System.Int32)">
            <summary>
            Forms a slice out of the given Vec, beginning at 'start', of given length
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The desired length for the slice (exclusive).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:Spreads.Native.Vec.ReferenceEquals(Spreads.Native.Vec)">
            <summary>
            Checks to see if two Vecs point at the same memory.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        </member>
        <member name="M:Spreads.Native.Vec.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> with the name of the type and the number of elements.
            </summary>
        </member>
        <member name="M:Spreads.Native.Vec.GetEnumerator">
            <summary>
            Returns an enumerator over the Slice's entire contents.
            </summary>
        </member>
        <member name="T:Spreads.Native.Vec.Enumerator">
            <summary>
            A struct-based enumerator, to make fast enumerations possible.
            This isn't designed for direct use, instead see GetEnumerator.
            </summary>
        </member>
        <member name="T:Spreads.Native.VecExtensions">
            <summary>
            Extension methods for <see cref="T:Spreads.Native.Vec`1"/>.
            </summary>
        </member>
        <member name="M:Spreads.Native.VecExtensions.AsVec``1(``0[],System.Int32)">
            <summary>
            Creates a new Vec over the portion of the target array.
            </summary>
        </member>
        <member name="M:Spreads.Native.VecExtensions.AsVec(System.Array,System.Int32)">
            <summary>
            Creates a new Vec over the portion of the target array.
            </summary>
        </member>
        <member name="M:Spreads.Native.VecExtensions.MoveBlock``1(Spreads.Native.Vec,System.Int32,System.Int32,System.Int32)">
            <summary>
            Move a block of values inside vector. Source and destination could overlap.
            </summary>
        </member>
        <member name="M:Spreads.Native.VecExtensions.MoveBlock``1(Spreads.Native.Vec{``0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Move a block of values inside vector. Source and destination could overlap.
            </summary>
        </member>
        <member name="M:Spreads.Native.VecHelpers.CopyTo``1(``0@,System.Int32,``0@,System.Int32)">
             <summary>
             Implements the copy functionality used by Span and ReadOnlySpan.
            
             NOTE: Fast span implements TryCopyTo in corelib and therefore this implementation
                   is only used by portable span. The code must live in code that only compiles
                   for portable span which means either each individual span implementation
                   of this shared code file. Other shared SpanHelper.X.cs files are compiled
                   for both portable and fast span implementations.
             </summary>
        </member>
        <member name="M:Spreads.Native.VecHelpers.Add``1(System.IntPtr,System.Int32)">
             <summary>
             Computes "start + index * sizeof(T)", using the unsigned IntPtr-sized multiplication for 32 and 64 bits.
            
             Assumptions:
                 Start and index are non-negative, and already pre-validated to be within the valid range of their containing Span.
            
                 If the byte length (Span.Length * sizeof(T)) does an unsigned overflow (i.e. the buffer wraps or is too big to fit within the address space),
                 the behavior is undefined.
            
             </summary>
        </member>
        <member name="M:Spreads.Native.VecHelpers.IsReferenceOrContainsReferences``1">
            <summary>
            Determine if a type is eligible for storage in unmanaged memory.
            Portable equivalent of RuntimeHelpers.IsReferenceOrContainsReferences{T}()
            </summary>
        </member>
        <member name="T:Spreads.Native.RuntimeVecInfo">
            TODO check actual size
        </member>
        <member name="T:Spreads.Native.VecTypeHelper.AppendOnlyStorage`1">
            <summary>
            A helper class to store types info
            </summary>
            <typeparam name="T"></typeparam>
        </member>
    </members>
</doc>
